diff --git a/Cargo.lock b/Cargo.lock
index ab9886a..311617b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -5879,6 +5879,16 @@ dependencies = [
  "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
 ]
 
+[[package]]
+name = "pallet-audit-trail"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-aura"
 version = "27.0.0"
@@ -5993,6 +6003,16 @@ dependencies = [
  "scale-info",
 ]
 
+[[package]]
+name = "pallet-dispute-mechanism"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-dynamic-fee"
 version = "4.0.0-dev"
@@ -6132,6 +6152,16 @@ dependencies = [
  "sp-io",
 ]
 
+[[package]]
+name = "pallet-governance"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-grandpa"
 version = "28.0.0"
@@ -6222,6 +6252,26 @@ dependencies = [
  "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
 ]
 
+[[package]]
+name = "pallet-light-clients"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
+[[package]]
+name = "pallet-machine-learning"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-multisig"
 version = "28.0.0"
@@ -6238,6 +6288,16 @@ dependencies = [
  "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
 ]
 
+[[package]]
+name = "pallet-oracle"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-parameters"
 version = "0.0.1"
@@ -6298,6 +6358,16 @@ dependencies = [
  "substrate-validator-set",
 ]
 
+[[package]]
+name = "pallet-reward-slashing"
+version = "0.1.0"
+dependencies = [
+ "frame-support",
+ "frame-system",
+ "scale-info",
+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
+]
+
 [[package]]
 name = "pallet-session"
 version = "28.0.0"
diff --git a/Cargo.toml b/Cargo.toml
index af8bf6f..3cfea8b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,8 +1,19 @@
 [workspace]
 members = [
-	"node",
-	"runtime",
-	"pallets/pallet-registration",
+    "node",
+    "runtime",
+    "pallets/audit-trail",
+    # "pallets/chain-listener",
+    "pallets/dispute-mechanism",
+    "pallets/governance",
+    "pallets/light-clients",
+    "pallets/machine-learning",
+    "pallets/oracle",
+    "pallets/pallet-epoch",
+    "pallets/pallet-registration",
+    "pallets/reward-slashing",
+    "pallets/substrate-validator-set",
+    # "pallets/vrf",
 ]
 resolver = "2"
 
diff --git a/diff.txt b/diff.txt
index 44cce1e..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,6950 +0,0 @@
-diff --git a/Cargo.toml b/Cargo.toml
-index 58d11b9..af8bf6f 100644
---- a/Cargo.toml
-+++ b/Cargo.toml
-@@ -206,7 +206,6 @@ sp-application-crypto = { git = "https://github.com/paritytech/polkadot-sdk", br
- 
- 
- 
--
- [profile.release]
- # Substrate runtime requires unwinding.
- panic = "unwind"
-diff --git a/diff.txt b/diff.txt
-index 938042e..e69de29 100644
---- a/diff.txt
-+++ b/diff.txt
-@@ -1,6207 +0,0 @@
--diff --git a/diff.txt b/diff.txt
--index d8cd6f5..e69de29 100644
----- a/diff.txt
--+++ b/diff.txt
--@@ -1,5368 +0,0 @@
---diff --git a/Cargo.lock b/Cargo.lock
---index f5673b8..ab9886a 100644
------ a/Cargo.lock
---+++ b/Cargo.lock
---@@ -6292,6 +6292,7 @@ dependencies = [
---  "sp-consensus-grandpa",
---  "sp-core",
---  "sp-io",
---+ "sp-keystore",
---  "sp-runtime",
---  "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
---  "substrate-validator-set",
---diff --git a/Cargo.toml b/Cargo.toml
---index 1feb05a..58d11b9 100644
------ a/Cargo.toml
---+++ b/Cargo.toml
---@@ -102,6 +102,7 @@ sp-genesis-builder = { git = "https://github.com/paritytech/polkadot-sdk", branc
--- sp-inherents = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
--- sp-io = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
--- sp-keyring = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0" }
---+sp-keystore = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0" }	
--- sp-offchain = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
--- sp-runtime = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
--- sp-runtime-interface = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
---diff --git a/diff.txt b/diff.txt
---index 5953fd1..e69de29 100644
------ a/diff.txt
---+++ b/diff.txt
---@@ -1,4779 +0,0 @@
----diff --git a/diff.txt b/diff.txt
----index f7f1a7c..e69de29 100644
------- a/diff.txt
----+++ b/diff.txt
----@@ -1,4226 +0,0 @@
-----diff --git a/Cargo.lock b/Cargo.lock
-----index 3fd599a..f5673b8 100644
-------- a/Cargo.lock
-----+++ b/Cargo.lock
-----@@ -6278,8 +6278,10 @@ dependencies = [
-----  "frame-benchmarking",
-----  "frame-support",
-----  "frame-system",
-----+ "hex-literal",
-----  "log",
-----  "mockall 0.12.1",
-----+ "pallet-im-online",
-----  "pallet-session",
-----  "parity-scale-codec",
-----  "scale-info",
-----@@ -6287,6 +6289,7 @@ dependencies = [
-----  "serde_json",
-----  "sp-application-crypto",
-----  "sp-consensus-aura",
-----+ "sp-consensus-grandpa",
-----  "sp-core",
-----  "sp-io",
-----  "sp-runtime",
-----diff --git a/diff.txt b/diff.txt
-----index 48d27e4..e69de29 100644
-------- a/diff.txt
-----+++ b/diff.txt
-----@@ -1,2391 +0,0 @@
------diff --git a/Cargo.lock b/Cargo.lock
------index f9ea4bd..3fd599a 100644
--------- a/Cargo.lock
------+++ b/Cargo.lock
------@@ -6271,6 +6271,29 @@ dependencies = [
------  "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
------ ]
------ 
------+[[package]]
------+name = "pallet-registration"
------+version = "1.1.0"
------+dependencies = [
------+ "frame-benchmarking",
------+ "frame-support",
------+ "frame-system",
------+ "log",
------+ "mockall 0.12.1",
------+ "pallet-session",
------+ "parity-scale-codec",
------+ "scale-info",
------+ "serde",
------+ "serde_json",
------+ "sp-application-crypto",
------+ "sp-consensus-aura",
------+ "sp-core",
------+ "sp-io",
------+ "sp-runtime",
------+ "sp-std 14.0.0 (git+https://github.com/paritytech/polkadot-sdk?branch=release-polkadot-v1.9.0)",
------+ "substrate-validator-set",
------+]
------+
------ [[package]]
------ name = "pallet-session"
------ version = "28.0.0"
------diff --git a/Cargo.toml b/Cargo.toml
------index bdd38b9..1feb05a 100644
--------- a/Cargo.toml
------+++ b/Cargo.toml
------@@ -2,6 +2,7 @@
------ members = [
------ 	"node",
------ 	"runtime",
------+	"pallets/pallet-registration",
------ ]
------ resolver = "2"
------ 
------diff --git a/diff.txt b/diff.txt
------index 7f1d684..e69de29 100644
--------- a/diff.txt
------+++ b/diff.txt
------@@ -1,248 +0,0 @@
-------diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
-------index f6ab345..9aad3dd 100644
---------- a/pallets/pallet-registration/src/lib.rs
-------+++ b/pallets/pallet-registration/src/lib.rs
-------@@ -551,6 +551,9 @@ pub mod pallet {
-------         fn some_extrinsic() -> Weight {
-------             Weight::zero()
-------         }
-------+        fn add_validator() -> Weight;
-------+        fn remove_validator() -> Weight;
-------+        fn register_validator() -> Weight;
-------     }
------- 
-------     impl WeightInfo for () {
-------diff --git a/pallets/substrate-validator-set/src/lib.rs b/pallets/substrate-validator-set/src/lib.rs
-------index e18ed5a..88bbb9c 100644
---------- a/pallets/substrate-validator-set/src/lib.rs
-------+++ b/pallets/substrate-validator-set/src/lib.rs
-------@@ -18,6 +18,7 @@ mod mock;
------- mod tests;
------- pub mod weights;
------- 
-------+use core::fmt::Debug;
------- use frame_support::{
------- 	ensure,
------- 	pallet_prelude::*,
-------@@ -27,6 +28,7 @@ use frame_support::{
------- use frame_system::pallet_prelude::*;
------- use log;
------- pub use pallet::*;
-------+use scale_info::TypeInfo;
------- use sp_runtime::traits::{Convert, Zero};
------- use sp_staking::offence::{Offence, OffenceError, ReportOffence};
------- use sp_std::prelude::*;
-------@@ -77,6 +79,7 @@ pub mod pallet {
------- 
------- 		/// Validator removal initiated. Effective in ~2 sessions.
------- 		ValidatorRemovalInitiated(T::ValidatorId),
-------+		ValidatorRegistered(T::ValidatorId),
------- 	}
------- 
------- 	// Errors inform users that something went wrong.
-------@@ -86,6 +89,8 @@ pub mod pallet {
------- 		TooLowValidatorCount,
------- 		/// Validator is already in the validator set.
------- 		Duplicate,
-------+		InvalidNFTMintEvent,
-------+		NotEligible,
------- 	}
------- 
------- 	#[pallet::hooks]
-------@@ -94,7 +99,7 @@ pub mod pallet {
------- 	#[pallet::genesis_config]
------- 	#[derive(DefaultNoBound)]
------- 	pub struct GenesisConfig<T: Config> {
--------		pub initial_validators: Vec<T::ValidatorId>,
-------+		pub initial_validators: Vec<<T as pallet_session::Config>::ValidatorId>,
------- 	}
------- 
------- 	#[pallet::genesis_build]
-------@@ -138,13 +143,66 @@ pub mod pallet {
------- 
------- 			Self::do_remove_validator(validator_id.clone())?;
------- 
-------+			Ok(())
-------+		}
-------+		#[pallet::call_index(2)]
-------+		#[pallet::weight(<T as pallet::Config>::WeightInfo::register_validator())]
-------+		pub fn register_validator(
-------+			origin: OriginFor<T>,
-------+			nft_policy_id: Vec<u8>,
-------+			nft_asset_name: Vec<u8>,
-------+			recipient_address: T::AccountId,
-------+			tx_hash: Vec<u8>,
-------+			tx_slot: u64,
-------+		) -> DispatchResult {
-------+			let who = ensure_signed(origin)?;
-------+
-------+			ensure!(
-------+				Self::verify_nft_mint_event(
-------+					&nft_policy_id,
-------+					&nft_asset_name,
-------+					&recipient_address,
-------+					&tx_hash,
-------+					tx_slot
-------+				),
-------+				Error::<T>::InvalidNFTMintEvent
-------+			);
-------+
-------+			ensure!(Self::is_eligible_validator(&recipient_address), Error::<T>::NotEligible);
-------+
-------+			let validator_id = T::ValidatorIdOf::convert(recipient_address.clone())
-------+				.ok_or(Error::<T>::NotEligible)?;
-------+
-------+			Self::do_add_validator(validator_id.clone())?;
-------+
-------+			Self::deposit_event(Event::ValidatorRegistered(validator_id));
-------+
------- 			Ok(())
------- 		}
------- 	}
------- }
------- 
------- impl<T: Config> Pallet<T> {
--------	fn do_add_validator(validator_id: T::ValidatorId) -> DispatchResult {
-------+	
-------+	fn verify_nft_mint_event(
-------+		nft_policy_id: &[u8],
-------+		nft_asset_name: &[u8],
-------+		recipient_address: &T::AccountId,
-------+		tx_hash: &[u8],
-------+		tx_slot: u64,
-------+	) -> bool {
-------+		// Implement your verification logic here
-------+		true // Placeholder implementation
-------+	}
-------+	
-------+	fn is_eligible_validator(account: &T::AccountId) -> bool {
-------+		// Implement your eligibility check logic here
-------+		true // Placeholder implementation
-------+	}
-------+	
-------+	fn do_add_validator(
-------+		validator_id: <T as pallet_session::Config>::ValidatorId,
-------+	) -> DispatchResult {
------- 		ensure!(!<Validators<T>>::get().contains(&validator_id), Error::<T>::Duplicate);
------- 		<Validators<T>>::mutate(|v| v.push(validator_id.clone()));
------- 
-------@@ -154,7 +212,9 @@ impl<T: Config> Pallet<T> {
------- 		Ok(())
------- 	}
------- 
--------	fn do_remove_validator(validator_id: T::ValidatorId) -> DispatchResult {
-------+	fn do_remove_validator(
-------+		validator_id: <T as pallet_session::Config>::ValidatorId,
-------+	) -> DispatchResult {
------- 		let mut validators = <Validators<T>>::get();
------- 
------- 		// Ensuring that the post removal, target validator count doesn't go
-------@@ -175,7 +235,7 @@ impl<T: Config> Pallet<T> {
------- 	}
------- 
------- 	// Adds offline validators to a local cache for removal on new session.
--------	fn mark_for_removal(validator_id: T::ValidatorId) {
-------+	fn mark_for_removal(validator_id: <T as pallet_session::Config>::ValidatorId) {
------- 		<OfflineValidators<T>>::mutate(|v| v.push(validator_id));
------- 		log::debug!(target: LOG_TARGET, "Offline validator marked for auto removal.");
------- 	}
-------@@ -242,14 +302,21 @@ impl<T: Config> EstimateNextSessionRotation<BlockNumberFor<T>> for Pallet<T> {
------- // Here it just returns the same ValidatorId.
------- pub struct ValidatorOf<T>(sp_std::marker::PhantomData<T>);
------- 
--------impl<T: Config> Convert<T::ValidatorId, Option<T::ValidatorId>> for ValidatorOf<T> {
--------	fn convert(account: T::ValidatorId) -> Option<T::ValidatorId> {
-------+impl<T: Config>
-------+	Convert<
-------+		<T as pallet_session::Config>::ValidatorId,
-------+		Option<<T as pallet_session::Config>::ValidatorId>,
-------+	> for ValidatorOf<T>
-------+{
-------+	fn convert(
-------+		account: <T as pallet_session::Config>::ValidatorId,
-------+	) -> Option<<T as pallet_session::Config>::ValidatorId> {
------- 		Some(account)
------- 	}
------- }
------- 
------- impl<T: Config> ValidatorSet<T::ValidatorId> for Pallet<T> {
--------	type ValidatorId = T::ValidatorId;
-------+	type ValidatorId = <T as pallet_session::Config>::ValidatorId;
------- 	type ValidatorIdOf = ValidatorOf<T>;
------- 
------- 	fn session_index() -> sp_staking::SessionIndex {
-------@@ -262,14 +329,24 @@ impl<T: Config> ValidatorSet<T::ValidatorId> for Pallet<T> {
------- }
------- 
------- impl<T: Config> ValidatorSetWithIdentification<T::ValidatorId> for Pallet<T> {
--------	type Identification = T::ValidatorId;
-------+	type Identification = <T as pallet_session::Config>::ValidatorId;
------- 	type IdentificationOf = ValidatorOf<T>;
------- }
------- 
------- // Offence reporting and unresponsiveness management.
------- // This is for the ImOnline pallet integration.
--------impl<T: Config, O: Offence<(T::ValidatorId, T::ValidatorId)>>
--------	ReportOffence<T::AccountId, (T::ValidatorId, T::ValidatorId), O> for Pallet<T>
-------+impl<
-------+		T: Config,
-------+		O: Offence<(
-------+			<T as pallet_session::Config>::ValidatorId,
-------+			<T as pallet_session::Config>::ValidatorId,
-------+		)>,
-------+	>
-------+	ReportOffence<
-------+		T::AccountId,
-------+		(<T as pallet_session::Config>::ValidatorId, <T as pallet_session::Config>::ValidatorId),
-------+		O,
-------+	> for Pallet<T>
------- {
------- 	fn report_offence(_reporters: Vec<T::AccountId>, offence: O) -> Result<(), OffenceError> {
------- 		let offenders = offence.offenders();
-------diff --git a/pallets/substrate-validator-set/src/mock.rs b/pallets/substrate-validator-set/src/mock.rs
-------index 3c1893e..8fc2282 100644
---------- a/pallets/substrate-validator-set/src/mock.rs
-------+++ b/pallets/substrate-validator-set/src/mock.rs
-------@@ -81,8 +81,8 @@ pub struct TestShouldEndSession;
------- impl ShouldEndSession<u64> for TestShouldEndSession {
------- 	fn should_end_session(now: u64) -> bool {
------- 		let l = SessionLength::get();
--------		now % l == 0 ||
--------			ForceSessionEnd::mutate(|l| {
-------+		now % l == 0
-------+			|| ForceSessionEnd::mutate(|l| {
------- 				let r = *l;
------- 				*l = false;
------- 				r
-------diff --git a/pallets/substrate-validator-set/src/weights.rs b/pallets/substrate-validator-set/src/weights.rs
-------index 645c8a5..13fc40c 100644
---------- a/pallets/substrate-validator-set/src/weights.rs
-------+++ b/pallets/substrate-validator-set/src/weights.rs
-------@@ -36,6 +36,7 @@ use core::marker::PhantomData;
------- pub trait WeightInfo {
------- 	fn add_validator() -> Weight;
------- 	fn remove_validator() -> Weight;
-------+	fn register_validator() -> Weight;
------- }
------- 
------- /// Weights for validator_set using the Substrate node and recommended hardware.
-------@@ -63,6 +64,9 @@ impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
------- 			.saturating_add(T::DbWeight::get().reads(1_u64))
------- 			.saturating_add(T::DbWeight::get().writes(1_u64))
------- 	}
-------+	fn register_validator() -> Weight {
-------+        Weight::from_parts(10_000_000_000, 0)
-------+    }
------- }
------- 
------- // For backwards compatibility and tests
-------@@ -89,5 +93,9 @@ impl WeightInfo for () {
------- 			.saturating_add(RocksDbWeight::get().reads(1_u64))
------- 			.saturating_add(RocksDbWeight::get().writes(1_u64))
------- 	}
-------+	fn register_validator() -> Weight {
-------+		Weight::from_parts(10_000_000_000, 0)
-------+	}
-------+	
------- }
------- 
------diff --git a/lib.rs b/lib.rs
------deleted file mode 100644
------index 187f103..0000000
--------- a/lib.rs
------+++ /dev/null
------@@ -1,1532 +0,0 @@
-------//! The Substrate Node Template runtime. This can be compiled with `#[no_std]`, ready for Wasm.
-------
-------#![cfg_attr(not(feature = "std"), no_std)]
-------// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.
-------#![recursion_limit = "256"]
-------#![allow(clippy::new_without_default, clippy::or_fun_call)]
-------#![cfg_attr(feature = "runtime-benchmarks", warn(unused_crate_dependencies))]
-------#[macro_use]
-------extern crate environmental;
-------
-------// Make the WASM binary available.
-------#[cfg(feature = "std")]
-------include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));
-------use scale_codec::{Decode, Encode};
-------use sp_api::impl_runtime_apis;
-------use sp_consensus_aura::sr25519::AuthorityId as AuraId;
-------
-------use sp_consensus_grandpa::{AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList};
-------use sp_core::{
-------    crypto::{ByteArray, KeyTypeId},
-------    OpaqueMetadata, H160, H256, U256,
-------};
-------use sp_runtime::{
-------    create_runtime_str, generic,
-------    generic::Era,
-------    impl_opaque_keys,
-------    traits::{
-------        BlakeTwo256, Block as BlockT, DispatchInfoOf, Dispatchable, Get, IdentifyAccount,
-------        IdentityLookup, NumberFor, One, OpaqueKeys, PostDispatchInfoOf, UniqueSaturatedInto,
-------        Verify,
-------    },
-------    transaction_validity::{
-------        TransactionPriority, TransactionSource, TransactionValidity, TransactionValidityError,
-------    },
-------    ApplyExtrinsicResult, ConsensusEngineId, ExtrinsicInclusionMode, Perbill, Permill,
-------    SaturatedConversion,
-------};
-------use sp_std::{marker::PhantomData, prelude::*};
-------use sp_version::RuntimeVersion;
-------use static_assertions::const_assert;
-------// Substrate FRAME
-------#[cfg(feature = "with-paritydb-weights")]
-------use frame_support::weights::constants::ParityDbWeight as RuntimeDbWeight;
-------#[cfg(feature = "with-rocksdb-weights")]
-------use frame_support::weights::constants::RocksDbWeight as RuntimeDbWeight;
-------use frame_support::{
-------    derive_impl,
-------    dynamic_params::dynamic_pallet_params,
-------    dynamic_params::dynamic_params,
-------    genesis_builder_helper::{build_config, create_default_config},
-------    pallet_prelude::DispatchClass,
-------    parameter_types,
-------    traits::{
-------        AsEnsureOriginWithArg, ConstBool, ConstU128, ConstU32, ConstU8, EnsureOriginWithArg,
-------        FindAuthor, Nothing, OnFinalize, OnTimestampSet,
-------    },
-------    weights::{
-------        constants::{BlockExecutionWeight, ExtrinsicBaseWeight, WEIGHT_REF_TIME_PER_MILLIS},
-------        IdentityFee, Weight,
-------    },
-------};
-------use frame_system::{EnsureRoot, EnsureSigned};
-------use pallet_transaction_payment::{ConstFeeMultiplier, CurrencyAdapter};
-------// Frontier
-------use fp_account::EthereumSignature;
-------use fp_evm::weight_per_gas;
-------use fp_rpc::TransactionStatus;
-------use pallet_ethereum::{
-------    Call::transact, PostLogContent, Transaction as EthereumTransaction, TransactionAction,
-------    TransactionData,
-------};
-------use pallet_evm::{
-------    Account as EVMAccount, EnsureAccountId20, FeeCalculator, IdentityAddressMapping, Runner,
-------};
-------use pallet_im_online::sr25519::AuthorityId as ImOnlineId;
-------
-------use sp_core::crypto::AccountId32;
-------use sp_runtime::MultiSigner;
-------mod account_id_conversion;
-------
-------use account_id_conversion::AccountId32Wrapper;
-------use fp_account::AccountId20;
-------
-------pub use frame_system::Call as SystemCall;
-------pub use pallet_balances::Call as BalancesCall;
-------pub use pallet_timestamp::Call as TimestampCall;
-------use pallet_transaction_payment::Multiplier;
-------
-------pub use pallet_epoch;
-------
-------mod precompiles;
-------
-------/// Runtime API definition for assets.
-------pub mod assets_api;
-------
-------use precompiles::FrontierPrecompiles;
-------
-------/// Type of block number.
-------pub type BlockNumber = u32;
-------
-------/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.
-------pub type Signature = EthereumSignature;
-------
-------/// Some way of identifying an account on the chain. We intentionally make it equivalent
-------/// to the public key of our transaction signing scheme.
-------pub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;
-------
-------/// The type for looking up accounts. We don't expect more than 4 billion of them, but you
-------/// never know...
-------pub type AccountIndex = u32;
-------
-------/// Balance of an account.
-------pub type Balance = u128;
-------
-------/// Index of a transaction in the chain.
-------pub type Nonce = u32;
-------
-------/// A hash of some data used by the chain.
-------pub type Hash = H256;
-------
-------/// The hashing algorithm used by the chain.
-------pub type Hashing = BlakeTwo256;
-------
-------/// Digest item type.
-------pub type DigestItem = generic::DigestItem;
-------
-------/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know
-------/// the specifics of the runtime. They can then be made to be agnostic over specific formats
-------/// of data like extrinsics, allowing for them to continue syncing the network through upgrades
-------/// to even the core data structures.
-------pub mod opaque {
-------    use super::*;
-------
-------    pub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;
-------
-------    /// Opaque block header type.
-------    pub type Header = generic::Header<BlockNumber, BlakeTwo256>;
-------    /// Opaque block type.
-------    pub type Block = generic::Block<Header, UncheckedExtrinsic>;
-------    /// Opaque block identifier type.
-------    pub type BlockId = generic::BlockId<Block>;
-------
-------    impl_opaque_keys! {
-------        pub struct SessionKeys {
-------            pub aura: Aura,
-------            pub grandpa: Grandpa,
-------            pub im_online: ImOnline,
-------        }
-------    }
-------}
-------
-------#[sp_version::runtime_version]
-------pub const VERSION: RuntimeVersion = RuntimeVersion {
-------    spec_name: create_runtime_str!("aya-node"),
-------    impl_name: create_runtime_str!("aya-node"),
-------    authoring_version: 1,
-------    spec_version: 1,
-------    impl_version: 1,
-------    apis: RUNTIME_API_VERSIONS,
-------    transaction_version: 1,
-------    state_version: 1,
-------};
-------
-------pub const MILLISECS_PER_BLOCK: u64 = 6000;
-------
-------pub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;
-------
-------// Time is measured by number of blocks.
-------pub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);
-------pub const HOURS: BlockNumber = MINUTES * 60;
-------pub const DAYS: BlockNumber = HOURS * 24;
-------
-------pub const MILLICENTS: Balance = 1_000_000_000;
-------pub const CENTS: Balance = 1_000 * MILLICENTS; // assume this is worth about a cent.
-------pub const DOLLARS: Balance = 100 * CENTS;
-------
-------pub const fn deposit(items: u32, bytes: u32) -> Balance {
-------    items as Balance * 15 * CENTS + (bytes as Balance) * 6 * CENTS
-------}
-------
-------/// The version information used to identify this runtime when compiled natively.
-------#[cfg(feature = "std")]
-------pub fn native_version() -> sp_version::NativeVersion {
-------    sp_version::NativeVersion {
-------        runtime_version: VERSION,
-------        can_author_with: Default::default(),
-------    }
-------}
-------
-------/// We assume that ~10% of the block weight is consumed by `on_initialize` handlers.
-------/// This is used to limit the maximal weight of a single extrinsic.
-------const AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(10);
-------const NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);
-------/// We allow for 2000ms of compute with a 6 second average block time.
-------pub const WEIGHT_MILLISECS_PER_BLOCK: u64 = 2000;
-------pub const MAXIMUM_BLOCK_WEIGHT: Weight = Weight::from_parts(
-------    WEIGHT_MILLISECS_PER_BLOCK * WEIGHT_REF_TIME_PER_MILLIS,
-------    u64::MAX,
-------);
-------pub const MAXIMUM_BLOCK_LENGTH: u32 = 5 * 1024 * 1024;
-------
-------parameter_types! {
-------    pub const Version: RuntimeVersion = VERSION;
-------    pub const BlockHashCount: BlockNumber = 256;
-------    pub BlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights
-------        ::with_sensible_defaults(MAXIMUM_BLOCK_WEIGHT, NORMAL_DISPATCH_RATIO);
-------    pub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength
-------        ::max_with_normal_ratio(MAXIMUM_BLOCK_LENGTH, NORMAL_DISPATCH_RATIO);
-------    pub const SS58Prefix: u16 = 1357;
-------    pub RuntimeBlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);
-------    pub RuntimeBlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights::builder()
-------        .base_block(BlockExecutionWeight::get())
-------        .for_class(DispatchClass::all(), |weights| {
-------            weights.base_extrinsic = ExtrinsicBaseWeight::get();
-------        })
-------        .for_class(DispatchClass::Normal, |weights| {
-------            weights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);
-------        })
-------        .for_class(DispatchClass::Operational, |weights| {
-------            weights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);
-------            // Operational transactions have some extra reserved space, so that they
-------            // are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.
-------            weights.reserved = Some(
-------                MAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT
-------            );
-------        })
-------        .avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)
-------        .build_or_panic();
-------}
-------
-------const_assert!(NORMAL_DISPATCH_RATIO.deconstruct() >= AVERAGE_ON_INITIALIZE_RATIO.deconstruct());
-------
-------// Configure FRAME pallets to include in runtime.
-------#[derive_impl(frame_system::config_preludes::SolochainDefaultConfig as frame_system::DefaultConfig)]
-------impl frame_system::Config for Runtime {
-------    /// The ubiquitous event type.
-------    type RuntimeEvent = RuntimeEvent;
-------    /// The basic call filter to use in dispatchable.
-------    type BaseCallFilter = frame_support::traits::Everything;
-------    /// Block & extrinsics weights: base values and limits.
-------    type BlockWeights = BlockWeights;
-------    /// The maximum length of a block (in bytes).
-------    type BlockLength = BlockLength;
-------    /// The ubiquitous origin type.
-------    type RuntimeOrigin = RuntimeOrigin;
-------    /// The aggregated dispatch type that is available for extrinsics.
-------    type RuntimeCall = RuntimeCall;
-------    /// The aggregated RuntimeTask type.
-------    type RuntimeTask = RuntimeTask;
-------    /// The index type for storing how many extrinsics an account has signed.
-------    type Nonce = Nonce;
-------    /// The type for hashing blocks and tries.
-------    type Hash = Hash;
-------    /// The hashing algorithm used.
-------    type Hashing = Hashing;
-------    /// The identifier used to distinguish between accounts.
-------    // type AccountId = AccountId;
-------    type AccountId = AccountId20;
-------    /// The lookup mechanism to get account ID from whatever is passed in dispatchers.
-------    type Lookup = IdentityLookup<AccountId>;
-------    /// The block type.
-------    type Block = Block;
-------    /// Maximum number of block number to block hash mappings to keep (oldest pruned first).
-------    type BlockHashCount = BlockHashCount;
-------    /// The weight of database operations that the runtime can invoke.
-------    type DbWeight = RuntimeDbWeight;
-------    /// Version of the runtime.
-------    type Version = Version;
-------    /// Converts a module to the index of the module in `construct_runtime!`.
-------    ///
-------    /// This type is being generated by `construct_runtime!`.
-------    type PalletInfo = PalletInfo;
-------    /// The data to be stored in an account.
-------    type AccountData = pallet_balances::AccountData<Balance>;
-------    /// What to do if a new account is created.
-------    type OnNewAccount = ();
-------    /// What to do if an account is fully reaped from the system.
-------    type OnKilledAccount = ();
-------    /// Weight information for the extrinsics of this pallet.
-------    type SystemWeightInfo = ();
-------    /// This is used as an identifier of the chain. 42 is the generic substrate prefix.
-------    type SS58Prefix = SS58Prefix;
-------    /// The set code logic, just the default since we're not a parachain.
-------    type OnSetCode = ();
-------    type MaxConsumers = ConstU32<16>;
-------}
-------
-------parameter_types! {
-------    pub const MaxAuthorities: u32 = 1000;
-------}
-------
-------impl pallet_aura::Config for Runtime {
-------    type AuthorityId = AuraId;
-------    type MaxAuthorities = MaxAuthorities;
-------    type DisabledValidators = ();
-------    type AllowMultipleBlocksPerSlot = ConstBool<false>;
-------}
-------
-------impl pallet_grandpa::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type WeightInfo = ();
-------    type MaxAuthorities = MaxAuthorities;
-------    type MaxNominators = ConstU32<0>;
-------    type MaxSetIdSessionEntries = ();
-------    type KeyOwnerProof = sp_core::Void;
-------    type EquivocationReportSystem = ();
-------}
-------
-------parameter_types! {
-------    pub const MinimumPeriod: u64 = SLOT_DURATION / 2;
-------    pub storage EnableManualSeal: bool = false;
-------}
-------
-------pub struct ConsensusOnTimestampSet<T>(PhantomData<T>);
-------impl<T: pallet_aura::Config> OnTimestampSet<T::Moment> for ConsensusOnTimestampSet<T> {
-------    fn on_timestamp_set(moment: T::Moment) {
-------        if EnableManualSeal::get() {
-------            return;
-------        }
-------        <pallet_aura::Pallet<T> as OnTimestampSet<T::Moment>>::on_timestamp_set(moment)
-------    }
-------}
-------
-------impl pallet_timestamp::Config for Runtime {
-------    /// A timestamp: milliseconds since the unix epoch.
-------    type Moment = u64;
-------    type OnTimestampSet = ConsensusOnTimestampSet<Self>;
-------    type MinimumPeriod = MinimumPeriod;
-------    type WeightInfo = ();
-------}
-------
-------parameter_types! {
-------    pub const MinAuthorities: u32 = 2;
-------}
-------
-------impl substrate_validator_set::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type AddRemoveOrigin = EnsureRoot<AccountId>;
-------    type MinAuthorities = MinAuthorities;
-------    type WeightInfo = ();
-------}
-------
-------#[derive(PartialEq, Eq, Clone, Debug)]
-------pub struct ValidatorId(pub AccountId20);
-------
-------impl From<ValidatorId> for AccountId32 {
-------    fn from(val: ValidatorId) -> Self {
-------        let mut bytes = [0u8; 32];
-------        let account_bytes: &[u8] = val.0.as_ref();
-------        bytes[0..20].copy_from_slice(&account_bytes[0..20]);
-------        AccountId32::from(bytes)
-------    }
-------}
-------
-------impl From<AccountId20> for ValidatorId {
-------    fn from(account_id: AccountId20) -> Self {
-------        ValidatorId(account_id)
-------    }
-------}
-------
-------impl From<ValidatorId> for AccountId20 {
-------    fn from(val: ValidatorId) -> Self {
-------        val.0
-------    }
-------}
-------
-------pub struct UnsignedPriority;
-------
-------impl Get<TransactionPriority> for UnsignedPriority {
-------    fn get() -> TransactionPriority {
-------        TransactionPriority::max_value()
-------    }
-------}
-------
-------impl pallet_epoch::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type WeightInfo = ();
-------    type AuthorityId = AuraId;
-------    type ValidatorId = ValidatorId;
-------    type AccountId32Convert = AccountId32Wrapper;
-------    type Call = RuntimeCall;
-------    type UnsignedPriority = UnsignedPriority;
-------}
-------
-------parameter_types! {
-------    pub const Period: u32 = 2 * MINUTES;
-------    pub const Offset: u32 = 0;
-------
-------}
-------
-------impl pallet_session::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------
-------    type ValidatorIdOf = substrate_validator_set::ValidatorOf<Self>;
-------    type ValidatorId = <Self as frame_system::Config>::AccountId;
-------    type ShouldEndSession = pallet_session::PeriodicSessions<Period, Offset>;
-------    type NextSessionRotation = pallet_session::PeriodicSessions<Period, Offset>;
-------    type SessionManager = ValidatorSet;
-------    type SessionHandler = <opaque::SessionKeys as OpaqueKeys>::KeyTypeIdProviders;
-------    type Keys = opaque::SessionKeys;
-------    type WeightInfo = pallet_session::weights::SubstrateWeight<Runtime>;
-------}
-------
-------parameter_types! {
-------    pub const ImOnlineUnsignedPriority: TransactionPriority = TransactionPriority::max_value();
-------    pub const MaxKeys: u32 = 10_000;
-------    pub const MaxPeerInHeartbeats: u32 = 10_000;
-------    pub const MaxPeerDataEncodingSize: u32 = 1_000;
-------}
-------
-------impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Runtime
-------where
-------    RuntimeCall: From<LocalCall>,
-------{
-------    fn create_transaction<C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>>(
-------        call: RuntimeCall,
-------        public: <Signature as Verify>::Signer,
-------        account: AccountId,
-------        nonce: Nonce,
-------    ) -> Option<(
-------        RuntimeCall,
-------        <UncheckedExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload,
-------    )> {
-------        let tip = 0;
-------        let period = BlockHashCount::get()
-------            .checked_next_power_of_two()
-------            .map(|c| c / 2)
-------            .unwrap_or(2) as u64;
-------        let current_block = System::block_number()
-------            .saturated_into::<u64>()
-------            .saturating_sub(1);
-------        let era = Era::mortal(period, current_block);
-------        let extra = (
-------            frame_system::CheckNonZeroSender::<Runtime>::new(),
-------            frame_system::CheckSpecVersion::<Runtime>::new(),
-------            frame_system::CheckTxVersion::<Runtime>::new(),
-------            frame_system::CheckGenesis::<Runtime>::new(),
-------            frame_system::CheckEra::<Runtime>::from(era),
-------            frame_system::CheckNonce::<Runtime>::from(nonce),
-------            frame_system::CheckWeight::<Runtime>::new(),
-------            pallet_transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
-------        );
-------        let raw_payload = SignedPayload::new(call, extra)
-------            .map_err(|e| {
-------                log::warn!("Unable to create signed payload: {:?}", e);
-------            })
-------            .ok()?;
-------        let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;
-------        let address = account;
-------        let (call, extra, _) = raw_payload.deconstruct();
-------        Some((call, (address, signature.into(), extra)))
-------    }
-------}
-------
-------impl frame_system::offchain::SigningTypes for Runtime {
-------    type Public = <Signature as Verify>::Signer;
-------    type Signature = Signature;
-------}
-------
-------impl<C> frame_system::offchain::SendTransactionTypes<C> for Runtime
-------where
-------    RuntimeCall: From<C>,
-------{
-------    type Extrinsic = UncheckedExtrinsic;
-------    type OverarchingCall = RuntimeCall;
-------}
-------
-------impl pallet_im_online::Config for Runtime {
-------    type AuthorityId = ImOnlineId;
-------    type RuntimeEvent = RuntimeEvent;
-------    type NextSessionRotation = pallet_session::PeriodicSessions<Period, Offset>;
-------    type ValidatorSet = ValidatorSet;
-------    type ReportUnresponsiveness = ValidatorSet;
-------    type UnsignedPriority = ImOnlineUnsignedPriority;
-------    type WeightInfo = pallet_im_online::weights::SubstrateWeight<Runtime>;
-------    type MaxKeys = MaxKeys;
-------    type MaxPeerInHeartbeats = MaxPeerInHeartbeats;
-------}
-------
-------parameter_types! {
-------    pub const ExistentialDeposit: u128 = 0;
-------    // For weight estimation, we assume that the most locks on an individual account will be 50.
-------    // This number may need to be adjusted in the future if this assumption no longer holds true.
-------    pub const MaxLocks: u32 = 50;
-------    pub const MaxReserves: u32 = 50;
-------}
-------
-------impl pallet_balances::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type RuntimeHoldReason = RuntimeHoldReason;
-------    type RuntimeFreezeReason = RuntimeFreezeReason;
-------    type WeightInfo = pallet_balances::weights::SubstrateWeight<Self>;
-------    type Balance = Balance;
-------    type DustRemoval = ();
-------    type ExistentialDeposit = ExistentialDeposit;
-------    type AccountStore = System;
-------    type ReserveIdentifier = [u8; 8];
-------    type FreezeIdentifier = RuntimeFreezeReason;
-------    type MaxLocks = MaxLocks;
-------    type MaxReserves = MaxReserves;
-------    type MaxFreezes = ConstU32<1>;
-------}
-------
-------parameter_types! {
-------    pub FeeMultiplier: Multiplier = Multiplier::one();
-------}
-------
-------impl pallet_transaction_payment::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type OnChargeTransaction = CurrencyAdapter<Balances, ()>;
-------    type WeightToFee = IdentityFee<Balance>;
-------    type LengthToFee = IdentityFee<Balance>;
-------    type FeeMultiplierUpdate = ConstFeeMultiplier<FeeMultiplier>;
-------    type OperationalFeeMultiplier = ConstU8<5>;
-------}
-------
-------impl pallet_sudo::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type RuntimeCall = RuntimeCall;
-------    type WeightInfo = pallet_sudo::weights::SubstrateWeight<Self>;
-------}
-------
-------parameter_types! {
-------    pub Schedule: pallet_contracts::Schedule<Runtime> = Default::default();
-------    pub CodeHashLockupDepositPercent: Perbill = Perbill::from_percent(30);
-------}
-------
-------impl pallet_contracts::Config for Runtime {
-------    type Time = Timestamp;
-------    type Randomness = RandomnessCollectiveFlip;
-------    type Currency = Balances;
-------    type RuntimeEvent = RuntimeEvent;
-------    type RuntimeCall = RuntimeCall;
-------    /// The safest default is to allow no calls at all.
-------    ///
-------    /// Runtimes should whitelist dispatchables that are allowed to be called from contracts
-------    /// and make sure they are stable. Dispatchables exposed to contracts are not allowed to
-------    /// change because that would break already deployed contracts. The `Call` structure itself
-------    /// is not allowed to change the indices of existing pallets, too.
-------    type CallFilter = Nothing;
-------    type DepositPerItem = dynamic_params::contracts::DepositPerItem;
-------    type DepositPerByte = dynamic_params::contracts::DepositPerByte;
-------    type DefaultDepositLimit = dynamic_params::contracts::DefaultDepositLimit;
-------    type CallStack = [pallet_contracts::Frame<Self>; 5];
-------    type WeightPrice = pallet_transaction_payment::Pallet<Self>;
-------    type WeightInfo = pallet_contracts::weights::SubstrateWeight<Self>;
-------    type ChainExtension = ();
-------    type Schedule = Schedule;
-------    type AddressGenerator = pallet_contracts::DefaultAddressGenerator;
-------    type MaxCodeLen = ConstU32<{ 123 * 1024 }>;
-------    type MaxStorageKeyLen = ConstU32<128>;
-------    type UnsafeUnstableInterface = ConstBool<false>;
-------    type UploadOrigin = EnsureSigned<Self::AccountId>;
-------    type InstantiateOrigin = EnsureSigned<Self::AccountId>;
-------    type MaxDebugBufferLen = ConstU32<{ 2 * 1024 * 1024 }>;
-------    type RuntimeHoldReason = RuntimeHoldReason;
-------    #[cfg(not(feature = "runtime-benchmarks"))]
-------    type Migrations = ();
-------    #[cfg(feature = "runtime-benchmarks")]
-------    type Migrations = pallet_contracts::migration::codegen::BenchMigrations;
-------    type MaxDelegateDependencies = ConstU32<32>;
-------    type CodeHashLockupDepositPercent = CodeHashLockupDepositPercent;
-------    type Debug = ();
-------    type Environment = ();
-------    type ApiVersion = ();
-------    type Xcm = ();
-------}
-------
-------parameter_types! {
-------    pub const IndexDeposit: Balance = 1 * DOLLARS;
-------}
-------
-------impl pallet_indices::Config for Runtime {
-------    type AccountIndex = AccountIndex;
-------    type Currency = Balances;
-------    type Deposit = IndexDeposit;
-------    type RuntimeEvent = RuntimeEvent;
-------    type WeightInfo = pallet_indices::weights::SubstrateWeight<Runtime>;
-------}
-------
-------parameter_types! {
-------    pub const AssetDeposit: Balance = 100 * DOLLARS;
-------    pub const ApprovalDeposit: Balance = 1 * DOLLARS;
-------    pub const StringLimit: u32 = 50;
-------    pub const MetadataDepositBase: Balance = 10 * DOLLARS;
-------    pub const MetadataDepositPerByte: Balance = 1 * DOLLARS;
-------}
-------impl pallet_assets::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type Balance = u128;
-------    type AssetId = u32;
-------    type AssetIdParameter = scale_codec::Compact<u32>;
-------    type Currency = Balances;
-------    type CreateOrigin = AsEnsureOriginWithArg<EnsureSigned<AccountId>>;
-------    type ForceOrigin = EnsureRoot<AccountId>;
-------    type AssetDeposit = crate::AssetDeposit;
-------    type AssetAccountDeposit = ConstU128<DOLLARS>;
-------    type MetadataDepositBase = crate::MetadataDepositBase;
-------    type MetadataDepositPerByte = crate::MetadataDepositPerByte;
-------    type ApprovalDeposit = crate::ApprovalDeposit;
-------    type StringLimit = crate::StringLimit;
-------    type Freezer = ();
-------    type Extra = ();
-------    type CallbackHandle = ();
-------    type WeightInfo = pallet_assets::weights::SubstrateWeight<Runtime>;
-------    type RemoveItemsLimit = ConstU32<1000>;
-------}
-------
-------parameter_types! {
-------    pub const CollectionDeposit: Balance = 100 * DOLLARS;
-------    pub const ItemDeposit: Balance = 1 * DOLLARS;
-------    pub const ApprovalsLimit: u32 = 20;
-------    pub const ItemAttributesApprovalsLimit: u32 = 20;
-------    pub const MaxTips: u32 = 10;
-------    pub const MaxDeadlineDuration: BlockNumber = 12 * 30 * DAYS;
-------}
-------
-------impl pallet_uniques::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type CollectionId = u32;
-------    type ItemId = u32;
-------    type Currency = Balances;
-------    type ForceOrigin = frame_system::EnsureRoot<AccountId>;
-------    type CollectionDeposit = CollectionDeposit;
-------    type ItemDeposit = ItemDeposit;
-------    type MetadataDepositBase = MetadataDepositBase;
-------    type AttributeDepositBase = MetadataDepositBase;
-------    type DepositPerByte = MetadataDepositPerByte;
-------    type StringLimit = ConstU32<128>;
-------    type KeyLimit = ConstU32<32>;
-------    type ValueLimit = ConstU32<64>;
-------    type WeightInfo = pallet_uniques::weights::SubstrateWeight<Runtime>;
-------    type CreateOrigin = AsEnsureOriginWithArg<EnsureSigned<AccountId>>;
-------    type Locker = ();
-------}
-------
-------impl pallet_evm_chain_id::Config for Runtime {}
-------
-------parameter_types! {
-------    pub const ConfigDepositBase: Balance = 5 * DOLLARS;
-------    pub const FriendDepositFactor: Balance = 50 * CENTS;
-------    pub const MaxFriends: u16 = 9;
-------    pub const RecoveryDeposit: Balance = 5 * DOLLARS;
-------}
-------
-------impl pallet_recovery::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type WeightInfo = pallet_recovery::weights::SubstrateWeight<Runtime>;
-------    type RuntimeCall = RuntimeCall;
-------    type Currency = Balances;
-------    type ConfigDepositBase = ConfigDepositBase;
-------    type FriendDepositFactor = FriendDepositFactor;
-------    type MaxFriends = MaxFriends;
-------    type RecoveryDeposit = RecoveryDeposit;
-------}
-------
-------pub struct FindAuthorTruncated<F>(PhantomData<F>);
-------impl<F: FindAuthor<u32>> FindAuthor<H160> for FindAuthorTruncated<F> {
-------    fn find_author<'a, I>(digests: I) -> Option<H160>
-------    where
-------        I: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,
-------    {
-------        if let Some(author_index) = F::find_author(digests) {
-------            let authority_id = Aura::authorities()[author_index as usize].clone();
-------            return Some(H160::from_slice(&authority_id.to_raw_vec()[4..24]));
-------        }
-------        None
-------    }
-------}
-------
-------const BLOCK_GAS_LIMIT: u64 = 75_000_000;
-------const MAX_POV_SIZE: u64 = 5 * 1024 * 1024;
-------
-------parameter_types! {
-------    pub BlockGasLimit: U256 = U256::from(BLOCK_GAS_LIMIT);
-------    pub const GasLimitPovSizeRatio: u64 = BLOCK_GAS_LIMIT.saturating_div(MAX_POV_SIZE);
-------    pub PrecompilesValue: FrontierPrecompiles<Runtime> = FrontierPrecompiles::<_>::new();
-------    pub WeightPerGas: Weight = Weight::from_parts(weight_per_gas(BLOCK_GAS_LIMIT, NORMAL_DISPATCH_RATIO, WEIGHT_MILLISECS_PER_BLOCK), 0);
-------    pub SuicideQuickClearLimit: u32 = 0;
-------}
-------
-------impl pallet_evm::Config for Runtime {
-------    type FeeCalculator = BaseFee;
-------    type GasWeightMapping = pallet_evm::FixedGasWeightMapping<Self>;
-------    type WeightPerGas = WeightPerGas;
-------    type BlockHashMapping = pallet_ethereum::EthereumBlockHashMapping<Self>;
-------    type CallOrigin = EnsureAccountId20;
-------    type WithdrawOrigin = EnsureAccountId20;
-------    type AddressMapping = IdentityAddressMapping;
-------    type Currency = Balances;
-------    type RuntimeEvent = RuntimeEvent;
-------    type PrecompilesType = FrontierPrecompiles<Self>;
-------    type PrecompilesValue = PrecompilesValue;
-------    type ChainId = EVMChainId;
-------    type BlockGasLimit = BlockGasLimit;
-------    type Runner = pallet_evm::runner::stack::Runner<Self>;
-------    type OnChargeTransaction = ();
-------    type OnCreate = ();
-------    type FindAuthor = FindAuthorTruncated<Aura>;
-------    type GasLimitPovSizeRatio = GasLimitPovSizeRatio;
-------    type SuicideQuickClearLimit = SuicideQuickClearLimit;
-------    type Timestamp = Timestamp;
-------    type WeightInfo = pallet_evm::weights::SubstrateWeight<Self>;
-------}
-------
-------parameter_types! {
-------    pub const PostBlockAndTxnHashes: PostLogContent = PostLogContent::BlockAndTxnHashes;
-------}
-------
-------impl pallet_ethereum::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type StateRoot = pallet_ethereum::IntermediateStateRoot<Self>;
-------    type PostLogContent = PostBlockAndTxnHashes;
-------    type ExtraDataLength = ConstU32<30>;
-------}
-------
-------parameter_types! {
-------    pub BoundDivision: U256 = U256::from(1024);
-------}
-------
-------impl pallet_dynamic_fee::Config for Runtime {
-------    type MinGasPriceBoundDivisor = BoundDivision;
-------}
-------
-------parameter_types! {
-------    pub DefaultBaseFeePerGas: U256 = U256::from(1_000_000_000);
-------    pub DefaultElasticity: Permill = Permill::from_parts(125_000);
-------}
-------
-------pub struct BaseFeeThreshold;
-------impl pallet_base_fee::BaseFeeThreshold for BaseFeeThreshold {
-------    fn lower() -> Permill {
-------        Permill::zero()
-------    }
-------    fn ideal() -> Permill {
-------        Permill::from_parts(500_000)
-------    }
-------    fn upper() -> Permill {
-------        Permill::from_parts(1_000_000)
-------    }
-------}
-------
-------impl pallet_base_fee::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type Threshold = BaseFeeThreshold;
-------    type DefaultBaseFeePerGas = DefaultBaseFeePerGas;
-------    type DefaultElasticity = DefaultElasticity;
-------}
-------
-------impl pallet_hotfix_sufficients::Config for Runtime {
-------    type AddressMapping = IdentityAddressMapping;
-------    type WeightInfo = pallet_hotfix_sufficients::weights::SubstrateWeight<Self>;
-------}
-------
-------pub struct DynamicParametersManagerOrigin;
-------impl EnsureOriginWithArg<RuntimeOrigin, RuntimeParametersKey> for DynamicParametersManagerOrigin {
-------    type Success = ();
-------
-------    fn try_origin(
-------        origin: RuntimeOrigin,
-------        key: &RuntimeParametersKey,
-------    ) -> Result<Self::Success, RuntimeOrigin> {
-------        match key {
-------            RuntimeParametersKey::Storage(_) => {
-------                frame_system::ensure_root(origin.clone()).map_err(|_| origin)?;
-------                return Ok(());
-------            }
-------            RuntimeParametersKey::Contract(_) => {
-------                frame_system::ensure_root(origin.clone()).map_err(|_| origin)?;
-------                return Ok(());
-------            }
-------        }
-------    }
-------
-------    #[cfg(feature = "runtime-benchmarks")]
-------    fn try_successful_origin(_key: &RuntimeParametersKey) -> Result<RuntimeOrigin, ()> {
-------        Ok(RuntimeOrigin::root())
-------    }
-------}
-------
-------impl pallet_parameters::Config for Runtime {
-------    type RuntimeParameters = RuntimeParameters;
-------    type RuntimeEvent = RuntimeEvent;
-------    type AdminOrigin = DynamicParametersManagerOrigin;
-------    type WeightInfo = ();
-------}
-------
-------#[frame_support::pallet]
-------pub mod pallet_manual_seal {
-------    use super::*;
-------    use frame_support::pallet_prelude::*;
-------
-------    #[pallet::pallet]
-------    pub struct Pallet<T>(PhantomData<T>);
-------
-------    #[pallet::config]
-------    pub trait Config: frame_system::Config {}
-------
-------    #[pallet::genesis_config]
-------    #[derive(frame_support::DefaultNoBound)]
-------    pub struct GenesisConfig<T> {
-------        pub enable: bool,
-------        #[serde(skip)]
-------        pub _config: PhantomData<T>,
-------    }
-------
-------    #[pallet::genesis_build]
-------    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
-------        fn build(&self) {
-------            EnableManualSeal::set(&self.enable);
-------        }
-------    }
-------}
-------
-------impl pallet_manual_seal::Config for Runtime {}
-------
-------impl pallet_insecure_randomness_collective_flip::Config for Runtime {}
-------
-------// Create the runtime by composing the FRAME pallets that were previously configured.
-------frame_support::construct_runtime!(
-------    pub enum Runtime {
-------        System: frame_system,
-------        Timestamp: pallet_timestamp,
-------        Balances: pallet_balances,
-------        ValidatorSet: substrate_validator_set,
-------        Epoch: pallet_epoch::{Pallet, Call, Storage, Event<T>, ValidateUnsigned},
-------        Session: pallet_session,
-------        ImOnline: pallet_im_online,
-------        Aura: pallet_aura,
-------        Grandpa: pallet_grandpa,
-------        TransactionPayment: pallet_transaction_payment,
-------        Sudo: pallet_sudo,
-------        Ethereum: pallet_ethereum,
-------        EVM: pallet_evm,
-------        EVMChainId: pallet_evm_chain_id,
-------        DynamicFee: pallet_dynamic_fee,
-------        BaseFee: pallet_base_fee,
-------        HotfixSufficients: pallet_hotfix_sufficients,
-------        ManualSeal: pallet_manual_seal,
-------        Contracts : pallet_contracts,
-------        Parameters: pallet_parameters,
-------        RandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip,
-------        Assets: pallet_assets,
-------        Indices: pallet_indices,
-------        Multisig: pallet_multisig,
-------        Recovery: pallet_recovery,
-------        Uniques: pallet_uniques,
-------    }
-------);
-------
-------parameter_types! {
-------    // One storage item; key size is 32; value is size 4+4+16+32 bytes = 56 bytes.
-------    pub const DepositBase: Balance = deposit(1, 88);
-------    // Additional storage item size of 32 bytes.
-------    pub const DepositFactor: Balance = deposit(0, 32);
-------}
-------
-------impl pallet_multisig::Config for Runtime {
-------    type RuntimeEvent = RuntimeEvent;
-------    type RuntimeCall = RuntimeCall;
-------    type Currency = Balances;
-------    type DepositBase = DepositBase;
-------    type DepositFactor = DepositFactor;
-------    type MaxSignatories = ConstU32<100>;
-------    type WeightInfo = pallet_multisig::weights::SubstrateWeight<Runtime>;
-------}
-------
-------#[derive(Clone)]
-------pub struct TransactionConverter;
-------
-------impl fp_rpc::ConvertTransaction<UncheckedExtrinsic> for TransactionConverter {
-------    fn convert_transaction(&self, transaction: pallet_ethereum::Transaction) -> UncheckedExtrinsic {
-------        UncheckedExtrinsic::new_unsigned(
-------            pallet_ethereum::Call::<Runtime>::transact { transaction }.into(),
-------        )
-------    }
-------}
-------
-------impl fp_rpc::ConvertTransaction<opaque::UncheckedExtrinsic> for TransactionConverter {
-------    fn convert_transaction(
-------        &self,
-------        transaction: pallet_ethereum::Transaction,
-------    ) -> opaque::UncheckedExtrinsic {
-------        let extrinsic = UncheckedExtrinsic::new_unsigned(
-------            pallet_ethereum::Call::<Runtime>::transact { transaction }.into(),
-------        );
-------        let encoded = extrinsic.encode();
-------        opaque::UncheckedExtrinsic::decode(&mut &encoded[..])
-------            .expect("Encoded extrinsic is always valid")
-------    }
-------}
-------
-------/// The address format for describing accounts.
-------pub type Address = AccountId;
-------/// Block header type as expected by this runtime.
-------pub type Header = generic::Header<BlockNumber, BlakeTwo256>;
-------/// Block type as expected by this runtime.
-------pub type Block = generic::Block<Header, UncheckedExtrinsic>;
-------/// A Block signed with a Justification
-------pub type SignedBlock = generic::SignedBlock<Block>;
-------/// BlockId type as expected by this runtime.
-------pub type BlockId = generic::BlockId<Block>;
-------/// The SignedExtension to the basic transaction logic.
-------pub type SignedExtra = (
-------    frame_system::CheckNonZeroSender<Runtime>,
-------    frame_system::CheckSpecVersion<Runtime>,
-------    frame_system::CheckTxVersion<Runtime>,
-------    frame_system::CheckGenesis<Runtime>,
-------    frame_system::CheckEra<Runtime>,
-------    frame_system::CheckNonce<Runtime>,
-------    frame_system::CheckWeight<Runtime>,
-------    pallet_transaction_payment::ChargeTransactionPayment<Runtime>,
-------);
-------/// Unchecked extrinsic type as expected by this runtime.
-------pub type UncheckedExtrinsic =
-------    fp_self_contained::UncheckedExtrinsic<Address, RuntimeCall, Signature, SignedExtra>;
-------/// Extrinsic type that has already been checked.
-------pub type CheckedExtrinsic =
-------    fp_self_contained::CheckedExtrinsic<AccountId, RuntimeCall, SignedExtra, H160>;
-------/// The payload being signed in transactions.
-------pub type SignedPayload = generic::SignedPayload<RuntimeCall, SignedExtra>;
-------/// Executive: handles dispatch to the various modules.
-------pub type Executive = frame_executive::Executive<
-------    Runtime,
-------    Block,
-------    frame_system::ChainContext<Runtime>,
-------    Runtime,
-------    AllPalletsWithSystem,
------->;
-------
-------type EventRecord = frame_system::EventRecord<
-------    <Runtime as frame_system::Config>::RuntimeEvent,
-------    <Runtime as frame_system::Config>::Hash,
------->;
-------
-------impl fp_self_contained::SelfContainedCall for RuntimeCall {
-------    type SignedInfo = H160;
-------
-------    fn is_self_contained(&self) -> bool {
-------        match self {
-------            RuntimeCall::Ethereum(call) => call.is_self_contained(),
-------            _ => false,
-------        }
-------    }
-------
-------    fn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {
-------        match self {
-------            RuntimeCall::Ethereum(call) => call.check_self_contained(),
-------            _ => None,
-------        }
-------    }
-------
-------    fn validate_self_contained(
-------        &self,
-------        info: &Self::SignedInfo,
-------        dispatch_info: &DispatchInfoOf<RuntimeCall>,
-------        len: usize,
-------    ) -> Option<TransactionValidity> {
-------        match self {
-------            RuntimeCall::Ethereum(call) => call.validate_self_contained(info, dispatch_info, len),
-------            _ => None,
-------        }
-------    }
-------
-------    fn pre_dispatch_self_contained(
-------        &self,
-------        info: &Self::SignedInfo,
-------        dispatch_info: &DispatchInfoOf<RuntimeCall>,
-------        len: usize,
-------    ) -> Option<Result<(), TransactionValidityError>> {
-------        match self {
-------            RuntimeCall::Ethereum(call) => {
-------                call.pre_dispatch_self_contained(info, dispatch_info, len)
-------            }
-------            _ => None,
-------        }
-------    }
-------
-------    fn apply_self_contained(
-------        self,
-------        info: Self::SignedInfo,
-------    ) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>> {
-------        match self {
-------            call @ RuntimeCall::Ethereum(pallet_ethereum::Call::transact { .. }) => {
-------                Some(call.dispatch(RuntimeOrigin::from(
-------                    pallet_ethereum::RawOrigin::EthereumTransaction(info),
-------                )))
-------            }
-------            _ => None,
-------        }
-------    }
-------}
-------
-------#[cfg(feature = "runtime-benchmarks")]
-------#[macro_use]
-------extern crate frame_benchmarking;
-------
-------#[cfg(feature = "runtime-benchmarks")]
-------mod benches {
-------    define_benchmarks!(
-------        [frame_benchmarking, BaselineBench::<Runtime>]
-------        [frame_system, SystemBench::<Runtime>]
-------        [pallet_balances, Balances]
-------        [pallet_timestamp, Timestamp]
-------        [pallet_sudo, Sudo]
-------        [pallet_contracts, Contracts]
-------        [pallet_parameters, Parameters]
-------        [pallet_evm, EVM]
-------    );
-------}
-------
-------impl_runtime_apis! {
-------    impl sp_api::Core<Block> for Runtime {
-------        fn version() -> RuntimeVersion {
-------            VERSION
-------        }
-------
-------        fn execute_block(block: Block) {
-------            Executive::execute_block(block)
-------        }
-------
-------        fn initialize_block(header: &<Block as BlockT>::Header) -> ExtrinsicInclusionMode {
-------            Executive::initialize_block(header)
-------        }
-------    }
-------
-------    impl sp_api::Metadata<Block> for Runtime {
-------        fn metadata() -> OpaqueMetadata {
-------            OpaqueMetadata::new(Runtime::metadata().into())
-------        }
-------
-------        fn metadata_at_version(version: u32) -> Option<OpaqueMetadata> {
-------            Runtime::metadata_at_version(version)
-------        }
-------
-------        fn metadata_versions() -> Vec<u32> {
-------            Runtime::metadata_versions()
-------        }
-------    }
-------
-------    impl sp_block_builder::BlockBuilder<Block> for Runtime {
-------        fn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {
-------            Executive::apply_extrinsic(extrinsic)
-------        }
-------
-------        fn finalize_block() -> <Block as BlockT>::Header {
-------            Executive::finalize_block()
-------        }
-------
-------        fn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {
-------            data.create_extrinsics()
-------        }
-------
-------        fn check_inherents(
-------            block: Block,
-------            data: sp_inherents::InherentData,
-------        ) -> sp_inherents::CheckInherentsResult {
-------            data.check_extrinsics(&block)
-------        }
-------    }
-------
-------    impl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {
-------        fn validate_transaction(
-------            source: TransactionSource,
-------            tx: <Block as BlockT>::Extrinsic,
-------            block_hash: <Block as BlockT>::Hash,
-------        ) -> TransactionValidity {
-------            Executive::validate_transaction(source, tx, block_hash)
-------        }
-------    }
-------
-------    impl sp_offchain::OffchainWorkerApi<Block> for Runtime {
-------        fn offchain_worker(header: &<Block as BlockT>::Header) {
-------            Executive::offchain_worker(header)
-------        }
-------    }
-------
-------    impl sp_genesis_builder::GenesisBuilder<Block> for Runtime {
-------        fn create_default_config() -> Vec<u8> {
-------            create_default_config::<RuntimeGenesisConfig>()
-------        }
-------
-------        fn build_config(config: Vec<u8>) -> sp_genesis_builder::Result {
-------            build_config::<RuntimeGenesisConfig>(config)
-------        }
-------    }
-------
-------    impl sp_session::SessionKeys<Block> for Runtime {
-------        fn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {
-------            opaque::SessionKeys::generate(seed)
-------        }
-------
-------        fn decode_session_keys(
-------            encoded: Vec<u8>,
-------        ) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {
-------            opaque::SessionKeys::decode_into_raw_public_keys(&encoded)
-------        }
-------    }
-------
-------    impl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {
-------        fn slot_duration() -> sp_consensus_aura::SlotDuration {
-------            sp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())
-------        }
-------
-------        fn authorities() -> Vec<AuraId> {
-------            Aura::authorities().to_vec()
-------        }
-------    }
-------
-------    impl sp_consensus_grandpa::GrandpaApi<Block> for Runtime {
-------        fn grandpa_authorities() -> GrandpaAuthorityList {
-------            Grandpa::grandpa_authorities()
-------        }
-------
-------        fn current_set_id() -> sp_consensus_grandpa::SetId {
-------            Grandpa::current_set_id()
-------        }
-------
-------        fn submit_report_equivocation_unsigned_extrinsic(
-------            _equivocation_proof: sp_consensus_grandpa::EquivocationProof<
-------                <Block as BlockT>::Hash,
-------                NumberFor<Block>,
-------            >,
-------            _key_owner_proof: sp_consensus_grandpa::OpaqueKeyOwnershipProof,
-------        ) -> Option<()> {
-------            None
-------        }
-------
-------        fn generate_key_ownership_proof(
-------            _set_id: sp_consensus_grandpa::SetId,
-------            _authority_id: GrandpaId,
-------        ) -> Option<sp_consensus_grandpa::OpaqueKeyOwnershipProof> {
-------            // NOTE: this is the only implementation possible since we've
-------            // defined our key owner proof type as a bottom type (i.e. a type
-------            // with no values).
-------            None
-------        }
-------    }
-------
-------    impl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Nonce> for Runtime {
-------        fn account_nonce(account: AccountId) -> Nonce {
-------            System::account_nonce(account)
-------        }
-------    }
-------
-------    impl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<
-------        Block,
-------        Balance,
-------    > for Runtime {
-------        fn query_info(
-------            uxt: <Block as BlockT>::Extrinsic,
-------            len: u32
-------        ) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {
-------            TransactionPayment::query_info(uxt, len)
-------        }
-------
-------        fn query_fee_details(
-------            uxt: <Block as BlockT>::Extrinsic,
-------            len: u32,
-------        ) -> pallet_transaction_payment::FeeDetails<Balance> {
-------            TransactionPayment::query_fee_details(uxt, len)
-------        }
-------
-------        fn query_weight_to_fee(weight: Weight) -> Balance {
-------            TransactionPayment::weight_to_fee(weight)
-------        }
-------
-------        fn query_length_to_fee(length: u32) -> Balance {
-------            TransactionPayment::length_to_fee(length)
-------        }
-------    }
-------
-------    impl fp_rpc::EthereumRuntimeRPCApi<Block> for Runtime {
-------        fn chain_id() -> u64 {
-------            <Runtime as pallet_evm::Config>::ChainId::get()
-------        }
-------
-------        fn account_basic(address: H160) -> EVMAccount {
-------            let (account, _) = pallet_evm::Pallet::<Runtime>::account_basic(&address);
-------            account
-------        }
-------
-------        fn gas_price() -> U256 {
-------            let (gas_price, _) = <Runtime as pallet_evm::Config>::FeeCalculator::min_gas_price();
-------            gas_price
-------        }
-------
-------        fn account_code_at(address: H160) -> Vec<u8> {
-------            pallet_evm::AccountCodes::<Runtime>::get(address)
-------        }
-------
-------        fn author() -> H160 {
-------            <pallet_evm::Pallet<Runtime>>::find_author()
-------        }
-------
-------        fn storage_at(address: H160, index: U256) -> H256 {
-------            let mut tmp = [0u8; 32];
-------            index.to_big_endian(&mut tmp);
-------            pallet_evm::AccountStorages::<Runtime>::get(address, H256::from_slice(&tmp[..]))
-------        }
-------
-------        fn call(
-------            from: H160,
-------            to: H160,
-------            data: Vec<u8>,
-------            value: U256,
-------            gas_limit: U256,
-------            max_fee_per_gas: Option<U256>,
-------            max_priority_fee_per_gas: Option<U256>,
-------            nonce: Option<U256>,
-------            estimate: bool,
-------            access_list: Option<Vec<(H160, Vec<H256>)>>,
-------        ) -> Result<pallet_evm::CallInfo, sp_runtime::DispatchError> {
-------            let config = if estimate {
-------                let mut config = <Runtime as pallet_evm::Config>::config().clone();
-------                config.estimate = true;
-------                Some(config)
-------            } else {
-------                None
-------            };
-------
-------            let gas_limit = gas_limit.min(u64::MAX.into());
-------            let transaction_data = TransactionData::new(
-------                TransactionAction::Call(to),
-------                data.clone(),
-------                nonce.unwrap_or_default(),
-------                gas_limit,
-------                None,
-------                max_fee_per_gas,
-------                max_priority_fee_per_gas,
-------                value,
-------                Some(<Runtime as pallet_evm::Config>::ChainId::get()),
-------                access_list.clone().unwrap_or_default(),
-------            );
-------            let (weight_limit, proof_size_base_cost) = pallet_ethereum::Pallet::<Runtime>::transaction_weight(&transaction_data);
-------
-------            <Runtime as pallet_evm::Config>::Runner::call(
-------                from,
-------                to,
-------                data,
-------                value,
-------                gas_limit.unique_saturated_into(),
-------                max_fee_per_gas,
-------                max_priority_fee_per_gas,
-------                nonce,
-------                access_list.unwrap_or_default(),
-------                false,
-------                true,
-------                weight_limit,
-------                proof_size_base_cost,
-------                config.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),
-------            ).map_err(|err| err.error.into())
-------        }
-------
-------        fn create(
-------            from: H160,
-------            data: Vec<u8>,
-------            value: U256,
-------            gas_limit: U256,
-------            max_fee_per_gas: Option<U256>,
-------            max_priority_fee_per_gas: Option<U256>,
-------            nonce: Option<U256>,
-------            estimate: bool,
-------            access_list: Option<Vec<(H160, Vec<H256>)>>,
-------        ) -> Result<pallet_evm::CreateInfo, sp_runtime::DispatchError> {
-------            let config = if estimate {
-------                let mut config = <Runtime as pallet_evm::Config>::config().clone();
-------                config.estimate = true;
-------                Some(config)
-------            } else {
-------                None
-------            };
-------
-------            let transaction_data = TransactionData::new(
-------                TransactionAction::Create,
-------                data.clone(),
-------                nonce.unwrap_or_default(),
-------                gas_limit,
-------                None,
-------                max_fee_per_gas,
-------                max_priority_fee_per_gas,
-------                value,
-------                Some(<Runtime as pallet_evm::Config>::ChainId::get()),
-------                access_list.clone().unwrap_or_default(),
-------            );
-------            let (weight_limit, proof_size_base_cost) = pallet_ethereum::Pallet::<Runtime>::transaction_weight(&transaction_data);
-------
-------            <Runtime as pallet_evm::Config>::Runner::create(
-------                from,
-------                data,
-------                value,
-------                gas_limit.unique_saturated_into(),
-------                max_fee_per_gas,
-------                max_priority_fee_per_gas,
-------                nonce,
-------                access_list.unwrap_or_default(),
-------                false,
-------                true,
-------                weight_limit,
-------                proof_size_base_cost,
-------                config.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),
-------            ).map_err(|err| err.error.into())
-------        }
-------
-------        fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
-------            pallet_ethereum::CurrentTransactionStatuses::<Runtime>::get()
-------        }
-------
-------        fn current_block() -> Option<pallet_ethereum::Block> {
-------            pallet_ethereum::CurrentBlock::<Runtime>::get()
-------        }
-------
-------        fn current_receipts() -> Option<Vec<pallet_ethereum::Receipt>> {
-------            pallet_ethereum::CurrentReceipts::<Runtime>::get()
-------        }
-------
-------        fn current_all() -> (
-------            Option<pallet_ethereum::Block>,
-------            Option<Vec<pallet_ethereum::Receipt>>,
-------            Option<Vec<TransactionStatus>>
-------        ) {
-------            (
-------                pallet_ethereum::CurrentBlock::<Runtime>::get(),
-------                pallet_ethereum::CurrentReceipts::<Runtime>::get(),
-------                pallet_ethereum::CurrentTransactionStatuses::<Runtime>::get()
-------            )
-------        }
-------
-------        fn extrinsic_filter(
-------            xts: Vec<<Block as BlockT>::Extrinsic>,
-------        ) -> Vec<EthereumTransaction> {
-------            xts.into_iter().filter_map(|xt| match xt.0.function {
-------                RuntimeCall::Ethereum(transact { transaction }) => Some(transaction),
-------                _ => None
-------            }).collect::<Vec<EthereumTransaction>>()
-------        }
-------
-------        fn elasticity() -> Option<Permill> {
-------            Some(pallet_base_fee::Elasticity::<Runtime>::get())
-------        }
-------
-------        fn gas_limit_multiplier_support() {}
-------
-------        fn pending_block(
-------            xts: Vec<<Block as BlockT>::Extrinsic>,
-------        ) -> (Option<pallet_ethereum::Block>, Option<Vec<TransactionStatus>>) {
-------            for ext in xts.into_iter() {
-------                let _ = Executive::apply_extrinsic(ext);
-------            }
-------
-------            Ethereum::on_finalize(System::block_number() + 1);
-------
-------            (
-------                pallet_ethereum::CurrentBlock::<Runtime>::get(),
-------                pallet_ethereum::CurrentTransactionStatuses::<Runtime>::get()
-------            )
-------        }
-------    }
-------
-------    impl fp_rpc::ConvertTransactionRuntimeApi<Block> for Runtime {
-------        fn convert_transaction(transaction: EthereumTransaction) -> <Block as BlockT>::Extrinsic {
-------            UncheckedExtrinsic::new_unsigned(
-------                pallet_ethereum::Call::<Runtime>::transact { transaction }.into(),
-------            )
-------        }
-------    }
-------
-------    #[cfg(feature = "runtime-benchmarks")]
-------    impl frame_benchmarking::Benchmark<Block> for Runtime {
-------        fn benchmark_metadata(extra: bool) -> (
-------            Vec<frame_benchmarking::BenchmarkList>,
-------            Vec<frame_support::traits::StorageInfo>,
-------        ) {
-------            use frame_benchmarking::{baseline, Benchmarking, BenchmarkList};
-------            use frame_support::traits::StorageInfoTrait;
-------
-------            use baseline::Pallet as BaselineBench;
-------            use frame_system_benchmarking::Pallet as SystemBench;
-------            use pallet_hotfix_sufficients::Pallet as PalletHotfixSufficients;
-------
-------            let mut list = Vec::<BenchmarkList>::new();
-------            list_benchmarks!(list, extra);
-------            list_benchmark!(list, extra, pallet_hotfix_sufficients, PalletHotfixSufficients::<Runtime>);
-------
-------            let storage_info = AllPalletsWithSystem::storage_info();
-------            (list, storage_info)
-------        }
-------
-------        fn dispatch_benchmark(
-------            config: frame_benchmarking::BenchmarkConfig
-------        ) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {
-------            use frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, add_benchmark};
-------            use frame_support::traits::TrackedStorageKey;
-------
-------            use pallet_evm::Pallet as PalletEvmBench;
-------            use pallet_hotfix_sufficients::Pallet as PalletHotfixSufficientsBench;
-------
-------            impl baseline::Config for Runtime {}
-------            impl frame_system_benchmarking::Config for Runtime {}
-------
-------            let whitelist: Vec<TrackedStorageKey> = vec![];
-------
-------            let mut batches = Vec::<BenchmarkBatch>::new();
-------            let params = (&config, &whitelist);
-------
-------            add_benchmark!(params, batches, pallet_evm, PalletEvmBench::<Runtime>);
-------            add_benchmark!(params, batches, pallet_hotfix_sufficients, PalletHotfixSufficientsBench::<Runtime>);
-------
-------            if batches.is_empty() { return Err("Benchmark not found for this pallet.".into()) }
-------            Ok(batches)
-------        }
-------    }
-------
-------    impl pallet_contracts::ContractsApi<Block, AccountId, Balance, BlockNumber, Hash, EventRecord> for Runtime
-------        {
-------            fn call(
-------                origin: AccountId,
-------                dest: AccountId,
-------                value: Balance,
-------                gas_limit: Option<Weight>,
-------                storage_deposit_limit: Option<Balance>,
-------                input_data: Vec<u8>,
-------            ) -> pallet_contracts::ContractExecResult<Balance, EventRecord> {
-------                let gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);
-------                Contracts::bare_call(
-------                    origin,
-------                    dest,
-------                    value,
-------                    gas_limit,
-------                    storage_deposit_limit,
-------                    input_data,
-------                    pallet_contracts::DebugInfo::UnsafeDebug,
-------                    pallet_contracts::CollectEvents::UnsafeCollect,
-------                    pallet_contracts::Determinism::Enforced,
-------                )
-------            }
-------
-------            fn instantiate(
-------                origin: AccountId,
-------                value: Balance,
-------                gas_limit: Option<Weight>,
-------                storage_deposit_limit: Option<Balance>,
-------                code: pallet_contracts::Code<Hash>,
-------                data: Vec<u8>,
-------                salt: Vec<u8>,
-------            ) -> pallet_contracts::ContractInstantiateResult<AccountId, Balance, EventRecord>
-------            {
-------                let gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);
-------                Contracts::bare_instantiate(
-------                    origin,
-------                    value,
-------                    gas_limit,
-------                    storage_deposit_limit,
-------                    code,
-------                    data,
-------                    salt,
-------                    pallet_contracts::DebugInfo::UnsafeDebug,
-------                    pallet_contracts::CollectEvents::UnsafeCollect,
-------                )
-------            }
-------
-------            fn upload_code(
-------                origin: AccountId,
-------                code: Vec<u8>,
-------                storage_deposit_limit: Option<Balance>,
-------                determinism: pallet_contracts::Determinism,
-------            ) -> pallet_contracts::CodeUploadResult<Hash, Balance>
-------            {
-------                Contracts::bare_upload_code(
-------                    origin,
-------                    code,
-------                    storage_deposit_limit,
-------                    determinism,
-------                )
-------            }
-------
-------            fn get_storage(
-------                address: AccountId,
-------                key: Vec<u8>,
-------            ) -> pallet_contracts::GetStorageResult {
-------                Contracts::get_storage(
-------                    address,
-------                    key
-------                )
-------            }
-------        }
-------}
-------
-------/// Dynamic parameters that can be changed at runtime through the
-------/// `pallet_parameters::set_parameter`.
-------#[dynamic_params(RuntimeParameters, pallet_parameters::Parameters::<Runtime>)]
-------pub mod dynamic_params {
-------    use super::*;
-------
-------    #[dynamic_pallet_params]
-------    #[codec(index = 0)]
-------    pub mod storage {
-------        /// Configures the base deposit of storing some data.
-------        #[codec(index = 0)]
-------        pub static BaseDeposit: Balance = 1 * DOLLARS;
-------
-------        /// Configures the per-byte deposit of storing some data.
-------        #[codec(index = 1)]
-------        pub static ByteDeposit: Balance = 1 * CENTS;
-------    }
-------
-------    #[dynamic_pallet_params]
-------    #[codec(index = 1)]
-------    pub mod contracts {
-------        #[codec(index = 0)]
-------        pub static DepositPerItem: Balance = deposit(1, 0);
-------
-------        #[codec(index = 1)]
-------        pub static DepositPerByte: Balance = deposit(0, 1);
-------
-------        #[codec(index = 2)]
-------        pub static DefaultDepositLimit: Balance = deposit(1024, 1024 * 1024);
-------    }
-------}
-------
-------#[cfg(test)]
-------mod tests {
-------    use super::{Runtime, WeightPerGas};
-------    #[test]
-------    fn configured_base_extrinsic_weight_is_evm_compatible() {
-------        let min_ethereum_transaction_weight = WeightPerGas::get() * 21_000;
-------        let base_extrinsic = <Runtime as frame_system::Config>::BlockWeights::get()
-------            .get(frame_support::dispatch::DispatchClass::Normal)
-------            .base_extrinsic;
-------        assert!(base_extrinsic.ref_time() <= min_ethereum_transaction_weight.ref_time());
-------    }
-------}
------diff --git a/pallets/pallet-registration/Cargo.toml b/pallets/pallet-registration/Cargo.toml
------index d491d46..02035ef 100644
--------- a/pallets/pallet-registration/Cargo.toml
------+++ b/pallets/pallet-registration/Cargo.toml
------@@ -11,56 +11,53 @@ license = 'Apache-2.0'
------ targets = ["x86_64-unknown-linux-gnu"]
------ 
------ [dependencies]
-------sp-core = { workspace = true }
-------sp-io = { workspace = true }
-------sp-runtime = { workspace = true }
-------frame-benchmarking = { workspace = true }
-------frame-support = { workspace = true }
-------frame-system = { workspace = true }
-------scale-info = { workspace = true }
-------log = { workspace = true }
-------scale-codec = { workspace = true }
-------sp-consensus-aura = { workspace = true }
-------sp-std = {workspace = true}
-------serde = { workspace = true }
-------serde_json = { workspace = true }
-------pallet-session = { workspace = true }
-------sp-application-crypto = { workspace = true }
-------substrate-validator-set = { workspace = true }
-------
------+sp-core = { workspace = true, default-features = false, features = ['std'] }
------+sp-io = { workspace = true, default-features = false, features = ['std'] }
------+sp-runtime = { workspace = true, default-features = false, features = ['std'] }
------+frame-benchmarking = { workspace = true, default-features = false, features = ['std'] }
------+frame-support = { workspace = true, default-features = false, features = ['std'] }
------+frame-system = { workspace = true, default-features = false, features = ['std'] }
------+scale-info = { workspace = true, default-features = false, features = ['std'] }
------+log = { workspace = true, default-features = false, features = ['std'] }
------+scale-codec = { workspace = true, default-features = false, features = ['std'] }
------+sp-consensus-aura = { workspace = true, default-features = false, features = ['std'] }
------+sp-std = { workspace = true, default-features = false, features = ['std'] }
------+serde = { workspace = true, default-features = false, features = ['std'] }
------+serde_json = { workspace = true, default-features = false, features = ['std'] }
------+pallet-session = { workspace = true, default-features = false, features = ['std'] }
------+sp-application-crypto = { workspace = true, default-features = false, features = ['std'] }
------+substrate-validator-set = { workspace = true, default-features = false, features = ['std'] }
------ 
------ [dev-dependencies]
-------
------ sp-consensus-aura = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
------ mockall = "0.12.1" 
------ 
-------
-------
------ [features]
------ default = ["std"]
------ std = [
-------	"scale-codec/std",
-------	"frame-benchmarking/std",
-------	"frame-support/std",
-------	"frame-system/std",
-------	"scale-info/std",
-------	"sp-core/std",
-------	"sp-io/std",
-------	"sp-runtime/std",
-------	"sp-std/std",
-------	"serde/std",
-------	"serde_json/std",
-------	"sp-application-crypto/std",
-------
------+    "scale-codec/std",
------+    "frame-benchmarking/std",
------+    "frame-support/std",
------+    "frame-system/std",
------+    "scale-info/std",
------+    "sp-core/std",
------+    "sp-io/std",
------+    "sp-runtime/std",
------+    "sp-std/std",
------+    "serde/std",
------+    "serde_json/std",
------+    "sp-application-crypto/std",
------ ]
------+
------ runtime-benchmarks = [
-------	"frame-benchmarking/runtime-benchmarks",
-------	"frame-support/runtime-benchmarks",
-------	"frame-system/runtime-benchmarks",
-------	"sp-runtime/runtime-benchmarks",
------+    "frame-benchmarking/runtime-benchmarks",
------+    "frame-support/runtime-benchmarks",
------+    "frame-system/runtime-benchmarks",
------+    "sp-runtime/runtime-benchmarks",
------ ]
------+
------ try-runtime = [
-------	"frame-support/try-runtime",
-------	"frame-system/try-runtime",
-------	"sp-runtime/try-runtime",
------+    "frame-support/try-runtime",
------+    "frame-system/try-runtime",
------+    "sp-runtime/try-runtime",
------ ]
------diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
------index 9aad3dd..797af9e 100644
--------- a/pallets/pallet-registration/src/lib.rs
------+++ b/pallets/pallet-registration/src/lib.rs
------@@ -5,8 +5,14 @@ extern crate serde;
------ extern crate sp_std;
------ use alloc::string::ToString;
------ pub use pallet::*;
------+pub mod types;
------+pub mod limits;
------+use types::{CustomData, EventType};
------+
------ #[cfg(test)]
------ mod tests;
------+#[cfg(test)]
------+mod mock;
------ 
------ #[cfg(feature = "runtime-benchmarks")]
------ mod benchmarking;
------@@ -551,9 +557,9 @@ pub mod pallet {
------         fn some_extrinsic() -> Weight {
------             Weight::zero()
------         }
-------        fn add_validator() -> Weight;
-------        fn remove_validator() -> Weight;
-------        fn register_validator() -> Weight;
------+        // fn add_validator() -> Weight;
------+        // fn remove_validator() -> Weight;
------+        // fn register_validator() -> Weight;
------     }
------ 
------     impl WeightInfo for () {
------diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
------index 8346461..b655376 100644
--------- a/pallets/pallet-registration/src/mock.rs
------+++ b/pallets/pallet-registration/src/mock.rs
------@@ -1,58 +1,212 @@
-------use crate as pallet_template;
------+#![cfg_attr(not(feature = "std"), no_std)]
------+
------+use crate::{CustomData, CustomEvent, EventType};
------ use frame_support::{
-------	derive_impl,
-------	traits::{ConstU16, ConstU64},
------+    construct_runtime, parameter_types,
------+    traits::{ConstU32, ConstU64, Everything, PalletInfo as FramePalletInfo},
------ };
-------use sp_core::H256;
------+use frame_system as system;
------+use scale_info::TypeInfo;
------+use serde::{Deserialize, Serialize};
------+use sp_application_crypto::{ed25519, RuntimePublic};
------+use sp_consensus_aura::sr25519::AuthorityId as AuraId;
------+use sp_core::{H256, offchain::KeyTypeId, Pair};
------ use sp_runtime::{
-------	traits::{BlakeTwo256, IdentityLookup},
-------	BuildStorage,
------+    app_crypto::{sr25519, RuntimeAppPublic},
------+    codec::{Decode, Encode, MaxEncodedLen},
------+    generic::{Era, SignedPayload},
------+    traits::{BlakeTwo256, IdentifyAccount, IdentityLookup, OpaqueKeys, SaturatedConversion, Verify},
------+    AccountId32, MultiSignature, BuildStorage,
------ };
------+use sp_runtime::impl_opaque_keys;
------+use sp_std::collections::btree_map::BTreeMap;
------+use substrate_validator_set;
------+use sp_runtime::testing::UintAuthorityId;
------ 
------ type Block = frame_system::mocking::MockBlock<Test>;
------ 
-------// Configure a mock runtime to test the pallet.
-------frame_support::construct_runtime!(
-------	pub enum Test
-------	{
-------		System: frame_system,
-------		TemplateModule: pallet_template,
-------	}
-------);
------+#[derive(Clone, PartialEq, Eq, Debug, Encode, Decode, MaxEncodedLen, TypeInfo, Serialize, Deserialize, Ord, PartialOrd)]
------+pub struct MyAccountId(u64);
------+
------+impl std::fmt::Display for MyAccountId {
------+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
------+        write!(f, "{}", self.0)
------+    }
------+}
------+
------+impl From<u64> for MyAccountId {
------+    fn from(value: u64) -> Self {
------+        MyAccountId(value)
------+    }
------+}
------+
------+impl From<AccountId32> for MyAccountId {
------+    fn from(account: AccountId32) -> Self {
------+        MockAccountId32Convert::into_account_id(account)
------+    }
------+}
------+
------+pub struct MockAccountId32Convert;
------+
------+impl MockAccountId32Convert {
------+    fn into_account_id(_account: AccountId32) -> MyAccountId {
------+        MyAccountId(0) // For testing purposes, always return 0
------+    }
------+
------+    fn into_account_id32(_account: MyAccountId) -> AccountId32 {
------+        AccountId32::new([0; 32]) // For testing purposes, return a zero-filled AccountId32
------+    }
------+}
------+
------+impl From<MockAccountId32Convert> for MyAccountId {
------+    fn from(_: MockAccountId32Convert) -> Self {
------+        MyAccountId(0)
------+    }
------+}
------+
------+impl Into<u64> for MockAccountId32Convert {
------+    fn into(self) -> u64 {
------+        0 // For testing purposes, always return 0
------+    }
------+}
------ 
-------#[derive_impl(frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig)]
------ impl frame_system::Config for Test {
-------	type BaseCallFilter = frame_support::traits::Everything;
-------	type BlockWeights = ();
-------	type BlockLength = ();
-------	type DbWeight = ();
-------	type RuntimeOrigin = RuntimeOrigin;
-------	type RuntimeCall = RuntimeCall;
-------	type Nonce = u64;
-------	type Hash = H256;
-------	type Hashing = BlakeTwo256;
-------	type AccountId = u64;
-------	type Lookup = IdentityLookup<Self::AccountId>;
-------	type Block = Block;
-------	type RuntimeEvent = RuntimeEvent;
-------	type BlockHashCount = ConstU64<250>;
-------	type Version = ();
-------	type PalletInfo = PalletInfo;
-------	type AccountData = ();
-------	type OnNewAccount = ();
-------	type OnKilledAccount = ();
-------	type SystemWeightInfo = ();
-------	type SS58Prefix = ConstU16<42>;
-------	type OnSetCode = ();
-------	type MaxConsumers = frame_support::traits::ConstU32<16>;
-------}
-------
-------impl pallet_template::Config for Test {
-------	type RuntimeEvent = RuntimeEvent;
-------	type WeightInfo = ();
-------}
-------
-------// Build genesis storage according to the mock runtime.
------+    type BaseCallFilter = Everything;
------+    type BlockWeights = ();
------+    type BlockLength = ();
------+    type DbWeight = ();
------+    type RuntimeOrigin = RuntimeOrigin;
------+    type RuntimeCall = RuntimeCall;
------+    type AccountId = MyAccountId;
------+    type Nonce = u64;
------+    type Hash = H256;
------+    type Hashing = BlakeTwo256;
------+    type Lookup = IdentityLookup<Self::AccountId>;
------+    type Block = Block;
------+    type RuntimeEvent = RuntimeEvent;
------+    type BlockHashCount = ConstU64<250>;
------+    type Version = ();
------+    type PalletInfo = PalletInfo;
------+    type AccountData = ();
------+    type OnNewAccount = ();
------+    type OnKilledAccount = ();
------+    type SystemWeightInfo = ();
------+    type SS58Prefix = sp_runtime::traits::ConstU16<42>;
------+    type OnSetCode = ();
------+    type MaxConsumers = ConstU32<16>;
------+
------+    // New associated types
------+    type RuntimeTask = ();
------+    type SingleBlockMigrations = ();
------+    type MultiBlockMigrator = ();
------+    type PreInherents = ();
------+    type PostInherents = ();
------+    type PostTransactions = ();
------+}
------+
------+parameter_types! {
------+    pub const EpochDuration: u64 = 10;
------+    pub const MinEpochLength: u64 = 5;
------+    pub static Validators: Vec<u64> = vec![1, 2, 3];
------+    pub static NextValidators: Vec<u64> = vec![1, 2, 3];
------+    pub static Authorities: Vec<UintAuthorityId> = vec![UintAuthorityId(1), UintAuthorityId(2), UintAuthorityId(3)];
------+    pub static ForceSessionEnd: bool = false;
------+    pub static SessionLength: u64 = 2;
------+    pub static SessionChanged: bool = false;
------+    pub static TestSessionChanged: bool = false;
------+    pub static Disabled: bool = false;
------+    pub static BeforeSessionEndCalled: bool = false;
------+    pub static ValidatorAccounts: BTreeMap<u64, u64> = BTreeMap::new();
------+    pub const BlockHashCount: u32 = 250;
------+}
------+
------+impl pallet_session::Config for Test {
------+    type RuntimeEvent = RuntimeEvent;
------+    type ValidatorId = MyAccountId;
------+    type ValidatorIdOf = substrate_validator_set::ValidatorOf<Self>;
------+    type ShouldEndSession = TestShouldEndSession;
------+    type NextSessionRotation = ();
------+    type SessionManager = substrate_validator_set::Pallet<Self>;
------+    type SessionHandler = TestSessionHandler;
------+    type Keys = MockSessionKeys;
------+    type WeightInfo = ();
------+}
------+
------+pub struct TestShouldEndSession;
------+
------+impl pallet_session::ShouldEndSession<u64> for TestShouldEndSession {
------+    fn should_end_session(_now: u64) -> bool {
------+        false
------+    }
------+}
------+
------+pub struct TestSessionHandler;
------+impl pallet_session::SessionHandler<MyAccountId> for TestSessionHandler {
------+    const KEY_TYPE_IDS: &'static [sp_runtime::KeyTypeId] = &[UintAuthorityId::ID];
------+
------+    fn on_genesis_session<T: OpaqueKeys>(_validators: &[(MyAccountId, T)]) {}
------+    fn on_new_session<T: OpaqueKeys>(
------+        _changed: bool,
------+        _validators: &[(MyAccountId, T)],
------+        _queued_validators: &[(MyAccountId, T)],
------+    ) {
------+    }
------+    fn on_disabled(_validator_index: u32) {}
------+    fn on_before_session_ending() {}
------+}
------+
------+impl substrate_validator_set::Config for Test {
------+    type RuntimeEvent = RuntimeEvent;
------+    type AddRemoveOrigin = frame_system::EnsureRoot<Self::AccountId>;
------+    type MinAuthorities = ConstU32<1>;
------+    type WeightInfo = ();
------+}
------+
------+impl_opaque_keys! {
------+    pub struct MockSessionKeys {
------+        pub dummy: UintAuthorityId,
------+    }
------+}
------+
------+construct_runtime!(
------+    pub enum Test {
------+        System: frame_system,
------+        ValidatorSet: substrate_validator_set,
------+        Session: pallet_session,
------+    }
------+);
------+
------+impl From<MyAccountId> for AccountId32 {
------+    fn from(account: MyAccountId) -> Self {
------+        AccountId32::new([0; 32])
------+    }
------+}
------+
------+impl From<AccountId32> for MockAccountId32Convert {
------+    fn from(_: AccountId32) -> Self {
------+        MockAccountId32Convert
------+    }
------+}
------+
------ pub fn new_test_ext() -> sp_io::TestExternalities {
-------	frame_system::GenesisConfig::<Test>::default().build_storage().unwrap().into()
------+    let storage = system::GenesisConfig::<Test>::default()
------+        .build_storage()
------+        .unwrap();
------+    let mut ext = sp_io::TestExternalities::new(storage);
------+    ext.execute_with(|| System::set_block_number(1));
------+    ext
------+}
------+
------+#[cfg(test)]
------+mod tests {
------+    use super::*;
------+    use frame_support::assert_ok;
------+    use sp_io::TestExternalities;
------+
------+    #[test]
------+    fn test_genesis_config_builds() {
------+        new_test_ext().execute_with(|| {
------+            assert_eq!(System::block_number(), 1);
------+        });
------+    }
------ }
------diff --git a/pallets/pallet-registration/src/tests.rs b/pallets/pallet-registration/src/tests.rs
------index 6c49191..2d978b2 100644
--------- a/pallets/pallet-registration/src/tests.rs
------+++ b/pallets/pallet-registration/src/tests.rs
------@@ -1,71 +1,71 @@
-------use crate::{mock::*, Error, Event, Something};
-------use frame_support::{assert_noop, assert_ok};
------+// use crate::{mock::*, Error, Event, Something};
------+// use frame_support::{assert_noop, assert_ok};
------ 
-------#[test]
-------fn it_works_for_default_value() {
-------    new_test_ext().execute_with(|| {
-------        // Go past genesis block so events get deposited
-------        System::set_block_number(1);
-------        // Dispatch a signed extrinsic.
-------        assert_ok!(TemplateModule::do_something(RuntimeOrigin::signed(1), 42));
-------        // Read pallet storage and assert an expected result.
-------        assert_eq!(Something::<Test>::get(), Some(42));
-------        // Assert that the correct event was deposited
-------        System::assert_last_event(
-------            Event::SomethingStored {
-------                something: 42,
-------                who: 1,
-------            }
-------            .into(),
-------        );
-------    });
-------}
------+// #[test]
------+// fn it_works_for_default_value() {
------+//     new_test_ext().execute_with(|| {
------+//         // Go past genesis block so events get deposited
------+//         System::set_block_number(1);
------+//         // Dispatch a signed extrinsic.
------+//         assert_ok!(TemplateModule::do_something(RuntimeOrigin::signed(1), 42));
------+//         // Read pallet storage and assert an expected result.
------+//         assert_eq!(Something::<Test>::get(), Some(42));
------+//         // Assert that the correct event was deposited
------+//         System::assert_last_event(
------+//             Event::SomethingStored {
------+//                 something: 42,
------+//                 who: 1,
------+//             }
------+//             .into(),
------+//         );
------+//     });
------+// }
------ 
-------#[test]
-------fn correct_error_for_none_value() {
-------    new_test_ext().execute_with(|| {
-------        // Ensure the expected error is thrown when no value is present.
-------        assert_noop!(
-------            TemplateModule::cause_error(RuntimeOrigin::signed(1)),
-------            Error::<Test>::NoneValue
-------        );
-------    });
-------}
------+// #[test]
------+// fn correct_error_for_none_value() {
------+//     new_test_ext().execute_with(|| {
------+//         // Ensure the expected error is thrown when no value is present.
------+//         assert_noop!(
------+//             TemplateModule::cause_error(RuntimeOrigin::signed(1)),
------+//             Error::<Test>::NoneValue
------+//         );
------+//     });
------+// }
------ 
-------// #[cfg(test)]
-------// mod tests {
-------//     use super::*;
-------//     use sp_core::offchain::{
-------//         testing::{self, OffchainState, OffchainWorkerExt, TestOffchainExt},
-------//         OffchainDbExt,
-------//     };
-------//     use sp_io::TestExternalities;
------+// // #[cfg(test)]
------+// // mod tests {
------+// //     use super::*;
------+// //     use sp_core::offchain::{
------+// //         testing::{self, OffchainState, OffchainWorkerExt, TestOffchainExt},
------+// //         OffchainDbExt,
------+// //     };
------+// //     use sp_io::TestExternalities;
------ 
-------//     fn setup_ext() -> TestExternalities {
-------//         let (offchain, _) = testing::TestOffchainExt::new();
-------//         let mut ext = TestExternalities::default();
-------//         ext.register_extension(OffchainWorkerExt(offchain));
-------//         ext
-------//     }
------+// //     fn setup_ext() -> TestExternalities {
------+// //         let (offchain, _) = testing::TestOffchainExt::new();
------+// //         let mut ext = TestExternalities::default();
------+// //         ext.register_extension(OffchainWorkerExt(offchain));
------+// //         ext
------+// //     }
------ 
-------//     #[test]
-------//     fn test_store_event_data() {
-------//         let mut ext = setup_ext();
-------//         ext.execute_with(|| {
-------//             // Assuming submit_cardano_event is a function callable here that triggers offchain storage logic
-------//             let event = Event { data: "Test event data".to_string() };
-------//             let event_str = serde_json::to_string(&event).unwrap();
-------//             submit_cardano_event(event_str).unwrap();
------+// //     #[test]
------+// //     fn test_store_event_data() {
------+// //         let mut ext = setup_ext();
------+// //         ext.execute_with(|| {
------+// //             // Assuming submit_cardano_event is a function callable here that triggers offchain storage logic
------+// //             let event = Event { data: "Test event data".to_string() };
------+// //             let event_str = serde_json::to_string(&event).unwrap();
------+// //             submit_cardano_event(event_str).unwrap();
------ 
-------//             let storage_key = sp_io::hashing::blake2_128(b"cardano_events");
------+// //             let storage_key = sp_io::hashing::blake2_128(b"cardano_events");
------ 
-------//             assert!(
-------//                 sp_io::offchain::local_storage_get(
-------//                     sp_runtime::offchain::StorageKind::PERSISTENT,
-------//                     &storage_key
-------//                 ).is_some(),
-------//                 "Event data should be stored"
-------//             );
-------//         });
-------//     }
-------// }
------+// //             assert!(
------+// //                 sp_io::offchain::local_storage_get(
------+// //                     sp_runtime::offchain::StorageKind::PERSISTENT,
------+// //                     &storage_key
------+// //                 ).is_some(),
------+// //                 "Event data should be stored"
------+// //             );
------+// //         });
------+// //     }
------+// // }
------diff --git a/runtime/src/lib.rs b/runtime/src/lib.rs
------index b45b120..fc5ae1e 100644
--------- a/runtime/src/lib.rs
------+++ b/runtime/src/lib.rs
------@@ -380,6 +380,15 @@ impl pallet_epoch::Config for Runtime {
------     type Call = RuntimeCall;
------     type UnsignedPriority = UnsignedPriority;
------ }
------+// impl pallet_registration::Config for Runtime {
------+//     type RuntimeEvent = RuntimeEvent;
------+//     type WeightInfo = ();
------+    // type AuthorityId = AuraId;
------+    // type ValidatorId = MVa  AccountId;
------+    // type AccountId32Convert = MockAccountId32Convert;
------+    // type Call = RuntimeCall;
------+    // type UnsignedPriority = frame_support::traits::ConstU64<100>;
------+// }
------ 
------ parameter_types! {
------     pub const Period: u32 = 2 * MINUTES;
-----diff --git a/pallets/pallet-epoch/src/mock.rs b/pallets/pallet-epoch/src/mock.rs
-----index 1fa1f4e..56c3555 100644
-------- a/pallets/pallet-epoch/src/mock.rs
-----+++ b/pallets/pallet-epoch/src/mock.rs
-----@@ -66,6 +66,7 @@ impl pallet_epoch::Config for Test {
-----     type Call = RuntimeCall;
-----     type UnsignedPriority = frame_support::traits::ConstU64<100>;
----- }
-----+
----- impl From<MyAccountId> for u64 {
-----     fn from(account: MyAccountId) -> Self {
-----         account.0
-----diff --git a/pallets/pallet-registration/Cargo.toml b/pallets/pallet-registration/Cargo.toml
-----index 02035ef..f81b6c9 100644
-------- a/pallets/pallet-registration/Cargo.toml
-----+++ b/pallets/pallet-registration/Cargo.toml
-----@@ -27,7 +27,9 @@ serde_json = { workspace = true, default-features = false, features = ['std'] }
----- pallet-session = { workspace = true, default-features = false, features = ['std'] }
----- sp-application-crypto = { workspace = true, default-features = false, features = ['std'] }
----- substrate-validator-set = { workspace = true, default-features = false, features = ['std'] }
------
-----+pallet-im-online = { workspace = true, default-features = false, features = ['std'] }
-----+sp-consensus-grandpa = { workspace = true, default-features = false, features = ['std'] }
-----+hex-literal = { workspace = true, default-features = false }    
----- [dev-dependencies]
----- sp-consensus-aura = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
----- mockall = "0.12.1" 
-----diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
-----index 797af9e..261370f 100644
-------- a/pallets/pallet-registration/src/lib.rs
-----+++ b/pallets/pallet-registration/src/lib.rs
-----@@ -3,98 +3,123 @@ extern crate alloc;
----- #[cfg_attr(feature = "std", macro_use)]
----- extern crate serde;
----- extern crate sp_std;
------use alloc::string::ToString;
-----+use alloc::format;
-----+use alloc::{string::ToString, vec::Vec};
-----+use core::primitive::str;
-----+use frame_support::traits::StorageInstance;
-----+use frame_support::{
-----+    dispatch::DispatchResult, pallet_prelude::*, storage::types::StorageMap,
-----+    unsigned::TransactionSource, weights::Weight,
-----+};
-----+use frame_system::{offchain::*, pallet_prelude::*};
-----+use hex_literal::hex;
-----+use log::info;
----- pub use pallet::*;
------pub mod types;
------pub mod limits;
------use types::{CustomData, EventType};
-----+use pallet_im_online::sr25519::AuthorityId as ImOnlineId;
-----+use serde::{Deserialize, Deserializer, Serialize, Serializer};
-----+use sp_application_crypto::ed25519::Signature;
-----+use sp_consensus_grandpa::AuthorityId as GrandpaId;
-----+use sp_core::sr25519::Public as Sr25519Public;
-----+use sp_runtime::traits::IdentifyAccount;
-----+
-----+use scale_info::TypeInfo;
-----+use serde_json;
-----+use serde_json::Value;
-----+use sp_application_crypto::{AppCrypto, RuntimePublic};
-----+use sp_core::crypto::KeyTypeId;
-----+use sp_io::crypto::ecdsa_sign;
-----+
-----+use sp_consensus_aura::sr25519::AuthorityId as AuraId;
-----+
-----+use sp_core::sr25519::Signature as Sr25519Signature;
-----+use sp_io::crypto::sr25519_sign;
-----+
-----+use sp_runtime::app_crypto::sp_core::crypto::Public;
-----+use sp_runtime::{
-----+    app_crypto::AppPublic,
-----+    codec::{Decode, Encode},
-----+    offchain::{self as rt_offchain},
-----+    traits::{Extrinsic as ExtrinsicT, ValidateUnsigned},
-----+};
-----+use substrate_validator_set as validator_set;
-----+
-----+use pallet_session;
-----+
-----+use frame_support::pallet_prelude::{BoundedVec, Get, MaxEncodedLen};
-----+use sp_runtime::AccountId32;
-----+use sp_std::prelude::*;
-----+
-----+use sp_application_crypto::sr25519;
-----+
-----+use sp_application_crypto::ed25519;
----- 
-----+use scale_info::prelude::string::String;
----- #[cfg(test)]
----- mod tests;
------#[cfg(test)]
------mod mock;
----- 
----- #[cfg(feature = "runtime-benchmarks")]
----- mod benchmarking;
-----+#[cfg(test)]
-----+mod mock; // Add this line to declare the mock module
----- pub mod weights;
----- 
------use alloc::vec::Vec;
------use frame_support::weights::Weight;
------use frame_support::{dispatch::DispatchResult, pallet_prelude::*, storage::types::StorageMap};
------use frame_system::{offchain::*, pallet_prelude::*};
------use sp_application_crypto::AppCrypto;
------use sp_core::H256;
------use sp_std::result;
------
------use sp_runtime::codec::{Decode, Encode};
------
------use scale_info::prelude::format;
------
------use serde_json;
------use sp_consensus_aura::ed25519::AuthorityId;
------use sp_core::Public;
------use sp_runtime::offchain::*;
------
------use frame_support::unsigned::TransactionSource;
------use scale_info::TypeInfo;
------use sp_core::offchain::Duration;
------use sp_runtime::offchain::http::Request;
------use sp_runtime::{
------    offchain as rt_offchain,
------    offchain::{
------        storage::StorageValueRef,
------        storage_lock::{BlockAndTime, StorageLock},
------    },
------};
------use sp_runtime::{Deserialize, Serialize};
------use sp_std::prelude::*;
------use  substrate_validator_set as validator_set;
-----+mod limits;
-----+pub mod types;
-----+use limits::{MaxDataLength, MaxEventsLength, MaxPayloadLength, MaxRemoveEventsLength};
-----+use types::{CustomData, CustomEvent, EpochChangeData};
----- 
-----+use sp_core::ecdsa::{Pair as EcdsaPair, Public as EcdsaPublic, Signature as EcdsaSignature};
-----+use sp_core::Pair;
----- 
------use sp_runtime::app_crypto::AppPublic;
------use sp_consensus_aura::sr25519::AuthorityId as AuraId;
------use sp_core::crypto::KeyTypeId;
-----+const KEY_TYPE: KeyTypeId = KeyTypeId(*b"aura");
----- 
-----+#[derive(Serialize, Deserialize)]
-----+struct ProcessedEventResult {
-----+    events: Vec<Vec<CustomEvent>>,
-----+    duplicates: Vec<Vec<CustomEvent>>,
-----+    success: bool,
-----+}
-----+use sp_runtime::traits::Verify;
-----+pub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;
----- 
------use pallet_session;
------#[derive(
------    Default, Deserialize, Serialize, Debug, Encode, Decode, Clone, PartialEq, Eq, TypeInfo,
------)]
------pub struct CustomEvent {
------    pub id: u64,
------    pub data: Vec<u8>,
------    pub timestamp: u64,
------    pub block_height: u64,
-----+#[derive(Debug, Deserialize)]
-----+struct JsonRpcResponse {
-----+    events: Vec<Vec<CustomEvent>>, // Adjusted to directly hold the list of CustomEvent
-----+    success: bool,
----- }
----- 
------impl CustomEvent {
------    fn new(
------        id: u64,
------        data: Vec<u8>,
------        timestamp: u64,
------        block_height: u64,
------    ) -> Self {
------        CustomEvent {
------            id,
------            data,
------            timestamp,
------            block_height,
------        }
------    }
-----+#[derive(Debug, Deserialize)]
-----+struct InnerResponse {
-----+    events: Vec<Vec<CustomEvent>>,
-----+    success: bool,
----- }
----- 
----- #[frame_support::pallet]
----- pub mod pallet {
-----     use super::*;
-----+    use sp_core::ByteArray;
----- 
-----     #[pallet::config]
------    pub trait Config: frame_system::Config + CreateSignedTransaction<Call<Self>> + validator_set::Config {
-----+    pub trait Config:
-----+        frame_system::Config
-----+        + CreateSignedTransaction<Call<Self>>
-----+        + validator_set::Config
-----+        + pallet_session::Config
-----+    {
-----         type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
-----         type WeightInfo: WeightInfo;
------        type AuthorityId: AppCrypto;
-----+        type AuthorityId: AppPublic
-----+            + From<sp_core::sr25519::Public>
-----+            + Into<sp_core::sr25519::Public>;
-----+        type ValidatorId: Clone
-----+            + From<Self::AccountId>
-----+            + Into<AccountId32>
-----+            + From<<Self as pallet_session::Config>::ValidatorId>;
-----+        type AccountId32Convert: From<AccountId32> + Into<Self::AccountId>;
-----+        type Call: From<Call<Self>>;
-----+        type UnsignedPriority: Get<u64>;
-----     }
----- 
------
-----     #[pallet::pallet]
-----     #[pallet::without_storage_info]
-----     pub struct Pallet<T>(_);
-----@@ -104,377 +129,729 @@ pub mod pallet {
-----     pub type EventStorage<T: Config> =
-----         StorageMap<_, Blake2_128Concat, u64, CustomEvent, ValueQuery>;
----- 
-----+    #[pallet::storage]
-----+    #[pallet::getter(fn processed_transactions)]
-----+    pub type ProcessedTransactions<T: Config> =
-----+        StorageMap<_, Blake2_128Concat, Vec<u8>, bool, OptionQuery>;
-----+
-----+    #[pallet::storage]
-----+    #[pallet::getter(fn pending_events)]
-----+    pub type PendingEvents<T: Config> = StorageMap<_, Blake2_128Concat, u64, (), OptionQuery>;
-----+
-----+    // Add the new storage item here
-----+    #[pallet::storage]
-----+    #[pallet::getter(fn processed_events)]
-----+    pub type ProcessedEvents<T: Config> = StorageMap<_, Blake2_128Concat, u64, bool, ValueQuery>;
-----+
-----     #[pallet::hooks]
-----     impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
-----         fn offchain_worker(block_number: BlockNumberFor<T>) {
------            // Step 3: Message Processing
-----+            // // Create and submit an inclusion transaction
-----+            // if let Err(e) = Self::create_inclusion_transaction() {
-----+            //     log::error!("Error creating inclusion transaction: {:?}", e);
-----+            // }
-----+            //check if registered as a validator
-----+            //if not check if event came in  for your credentials
-----+            // if !Self::is_leader() {
-----+            //     return;
-----+            // }
-----+            // todo leader election
-----             if let Err(e) = Self::fetch_and_process_events_from_queue() {
------                log::error!("Error fetching and processing events: {:?}", e);
------            }
------
------            // Check if the validator is the leader
------            if Self::is_leader() {
------                // Create and submit an inclusion transaction
------                if let Err(e) = Self::create_inclusion_transaction() {
------                    log::error!("Error creating inclusion transaction: {:?}", e);
------                }
-----+                log::error!("Error processing events: {:?}", e);
-----             }
-----         }
-----     }
----- 
------    impl<T: Config> Pallet<T>
------    // where
------    //     T::AuthorityId: From<sr25519::Public> + PartialEq<<T as pallet_session::Config>::ValidatorId>,
------    {
------        // Step 5: Message Cleanup
------        fn cleanup_processed_events() {
------            // Remove events from storage that have been included in the blockchain
------            for event_id in EventStorage::<T>::iter_keys() {
------                EventStorage::<T>::remove(event_id);
------            }
------        }
-----+    #[pallet::validate_unsigned]
-----+    impl<T: Config> ValidateUnsigned for Pallet<T> {
-----+        type Call = Call<T>;
----- 
------        // fn fetch_local_keys() -> Vec<T::AuthorityId> {
------        //     // let key_type_id = T::AuthorityId::ID;
------        //     // sp_io::crypto::sr25519_public_keys(key_type_id)
------        //     //     .into_iter()
------        //     //     .map(|key| T::AuthorityId::from(key))
------        //     //     .collect()
------        // }
-----+        fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
-----+            // Only accept transactions from local or in-block sources
-----+            if !matches!(
-----+                source,
-----+                TransactionSource::Local | TransactionSource::InBlock
-----+            ) {
-----+                return InvalidTransaction::Call.into();
-----+            }
----- 
------        fn is_leader() -> bool {
------            let validators = validator_set::Validators::<T>::get();
------            let current_index = pallet_session::Pallet::<T>::current_index();
-----+            match call {
-----+                Call::submit_encoded_payload { payload } => {
-----+                    // Decode the payload to extract the event
-----+                    let event = match CustomEvent::decode(&mut &payload[..]) {
-----+                        Ok(event) => event,
-----+                        Err(e) => {
-----+                            log::error!("Failed to decode event from payload: {:?}", e);
-----+                            return InvalidTransaction::BadProof.into();
-----+                        }
-----+                    };
-----+
-----+                    // Check if the event is a duplicate
-----+                    if Self::is_duplicate(&event) {
-----+                        log::warn!("Duplicate event detected: {:?}", event);
-----+                        return InvalidTransaction::Stale.into();
-----+                    }
----- 
------            if let Some(leader) = validators.get(current_index as usize % validators.len()) {
------                // let local_keys = Self::fetch_local_keys();
-----+                    // Perform additional validation if needed
----- 
------                // for local_key in local_keys {
------                //     if local_key == *leader {
------                //         return true;
------                //     }
------                // }
-----+                    ValidTransaction::with_tag_prefix("OffchainWorker")
-----+                        .priority(TransactionPriority::max_value())
-----+                        .longevity(TransactionLongevity::max_value())
-----+                        .propagate(true)
-----+                        .build()
-----+                }
-----+                _ => InvalidTransaction::Call.into(),
-----             }
------            false
-----         }
------    
------
------        fn fetch_all_events() -> Result<Vec<u8>, Error<T>> {
------            const HTTP_REMOTE_REQUEST: &str = "http://127.0.0.1:5555";
------            const HTTP_HEADER_USER_AGENT: &str = "SubstrateOffchainWorker";
------            const HTTP_HEADER_CONTENT_TYPE: &str = "Content-Type";
------            const CONTENT_TYPE_JSON: &str = "application/json";
------            const FETCH_TIMEOUT_PERIOD: u64 = 3000; // in milliseconds
-----+    }
----- 
------            // Create the JSON-RPC request payload
------            let json_payload = serde_json::json!({
-----+    impl<T: Config> Pallet<T>
-----+    where
-----+        <T as pallet::Config>::ValidatorId:
-----+            Clone + Into<AccountId32> + From<<T as pallet_session::Config>::ValidatorId>,
-----+        <T as pallet_session::Config>::ValidatorId: Clone,
-----+    {
-----+        fn convert_session_validator_id_to_pallet_validator_id(
-----+            key: <T as pallet_session::Config>::ValidatorId,
-----+        ) -> <T as pallet::Config>::ValidatorId {
-----+            key.into()
-----+        }
-----+    }
-----+    impl<T: Config> Pallet<T>
-----+    where
-----+        T: frame_system::offchain::SendTransactionTypes<Call<T>>,
-----+    {
-----+        fn fetch_event_id(event_id: u64) -> Result<String, Error<T>> {
-----+            let url = "http://127.0.0.1:5555";
-----+            let request_body = serde_json::json!({
-----                 "jsonrpc": "2.0",
------                "method": "list_all_events",
------                "params": [],
-----+                "method": "get_event_id",
-----+                "params": [event_id],
-----                 "id": 1
-----             })
------            .to_string()
------            .into_bytes();
------            let json_payload_ref: Vec<&[u8]> = vec![&json_payload];
------
------            // Initiate an external HTTP POST request. This is using high-level wrappers from `sp_runtime`.
------            let request = rt_offchain::http::Request::post(HTTP_REMOTE_REQUEST, json_payload_ref);
------
------            // Keeping the offchain worker execution time reasonable, so limiting the call to be within 3s.
------            let timeout = sp_io::offchain::timestamp()
------                .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD));
------
------            // Set the request headers
------            let pending = request
------                .add_header("User-Agent", HTTP_HEADER_USER_AGENT)
------                .add_header(HTTP_HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON)
------                .deadline(timeout) // Setting the timeout time
------                .send() // Sending the request out by the host
-----+            .to_string();
-----+
-----+            let request = rt_offchain::http::Request::post(url, vec![request_body.into_bytes()])
-----+                .add_header("Content-Type", "application/json")
-----+                .add_header("User-Agent", "SubstrateOffchainWorker")
-----+                .deadline(
-----+                    sp_io::offchain::timestamp().add(rt_offchain::Duration::from_millis(3000)),
-----+                )
-----+                .send()
-----                 .map_err(|_| <Error<T>>::HttpFetchingError)?;
----- 
------            let response = pending
------                .try_wait(timeout)
-----+            let response = request
-----+                .try_wait(
-----+                    sp_io::offchain::timestamp().add(rt_offchain::Duration::from_millis(3000)),
-----+                )
-----                 .map_err(|_| <Error<T>>::HttpFetchingError)?
-----                 .map_err(|_| <Error<T>>::HttpFetchingError)?;
----- 
------            log::info!("Response code: {}", response.code);
-----+            if response.code != 200 {
-----+                log::error!("Unexpected response code: {}", response.code);
-----+                return Err(<Error<T>>::HttpFetchingError);
-----+            }
----- 
-----             let body = response.body().collect::<Vec<u8>>();
------            match String::from_utf8(body.clone()) {
------                Ok(json_string) => {
------                    log::info!("Response body: {}", json_string);
-----+            let body_str = sp_std::str::from_utf8(&body).map_err(|_| <Error<T>>::InvalidUtf8)?;
-----+
-----+            let json: serde_json::Value =
-----+                serde_json::from_str(body_str).map_err(|_| <Error<T>>::JsonSerializationError)?;
-----+            if json["success"].as_bool().unwrap_or(false) {
-----+                if let Some(event_id) = json["event_id"].as_str() {
-----+                    return Ok(event_id.to_string());
-----                 }
------                Err(e) => {
------                    log::error!("Failed to parse response body as UTF-8: {:?}", e);
------                    log::info!("Response body bytes: {:?}", body);
-----+            }
-----+
-----+            Err(<Error<T>>::InvalidResponseFormat)
-----+        }
-----+        fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
-----+            log::info!("Fetching all events from the queue");
-----+
-----+            let response = Self::process_real_event()?;
-----+            let response_data: ProcessedEventResult =
-----+                serde_json::from_slice(&response).map_err(|e| {
-----+                    log::error!("Failed to deserialize events: {:?}", e);
-----+                    <Error<T>>::JsonSerializationError
-----+                })?;
-----+
-----+            let events = response_data.events;
-----+            let duplicates = response_data.duplicates;
-----+
-----+            for event_group in events.into_iter() {
-----+                for event in event_group {
-----+                    log::info!("Processing event: {:?}", event);
-----+
-----+                    // Check if the event has already been processed
-----+                    if ProcessedEvents::<T>::contains_key(event.id) {
-----+                        log::info!("Event {} is already processed", event.id);
-----+                        Self::remove_event_from_priority_queue(event.id).ok(); // Ensure to remove already processed events
-----+                        continue;
-----+                    }
-----+
-----+                    let payload = event.encode();
-----+                    if !ProcessedTransactions::<T>::contains_key(&payload) {
-----+                        log::info!("Attempting to submit unsigned transaction with payload: {:?} and event_id: {}", payload, event.id);
-----+                        match Self::submit_unsigned_transaction(payload.clone(), event.id) {
-----+                            Ok(_) => {
-----+                                log::info!(
-----+                                    "Transaction submitted successfully for event ID: {}",
-----+                                    event.id
-----+                                );
-----+                                ProcessedEvents::<T>::insert(event.id, true); // Mark the event as processed
-----+                                Self::remove_event_from_priority_queue(event.id).ok();
-----+                                // Remove the event from the priority queue
-----+                            }
-----+                            Err(e) => {
-----+                                log::error!("Error submitting unsigned transaction: {:?}", e);
-----+                            }
-----+                        }
-----+                    } else {
-----+                        log::info!("Event {} is already processed", event.id);
-----+                        Self::remove_event_from_priority_queue(event.id).ok(); // Ensure to remove already processed events
-----+                    }
-----                 }
-----             }
----- 
------            if response.code != 200 {
------                return Err(<Error<T>>::HttpFetchingError);
-----+            // Process duplicates separately
-----+            for event_group in duplicates.into_iter() {
-----+                for event in event_group {
-----+                    log::info!("Duplicate event detected: {:?}", event);
-----+                    Self::remove_event_from_priority_queue(event.id).ok(); // Remove the duplicate event from the priority queue
-----+                }
-----             }
----- 
------            // Next we fully read the response body and collect it to a vector of bytes.
------            Ok(body)
-----+            Ok(())
-----         }
-----+    }
----- 
------       
-----+    use alloc::format;
----- 
------        fn fetch_remote_events() -> Vec<CustomEvent> {
------            // Implement the logic to fetch remote events from other nodes.
------            // This might involve sending HTTP requests to other nodes and parsing the responses.
------            // For simplicity, let's assume we have the URLs of other nodes stored somewhere.
-----+    impl<T: Config> Pallet<T> {
-----+        fn submit_unsigned_transaction(
-----+            payload: Vec<u8>,
-----+            event_id: u64,
-----+        ) -> Result<(), &'static str> {
-----+            log::info!(
-----+                "Attempting to submit unsigned transaction with payload: {:?} and event_id: {}",
-----+                payload,
-----+                event_id
-----+            );
----- 
------            // let urls = vec!["http://node1:5555", "http://node2:5555"]; // Replace with actual URLs
------            let mut all_events = Vec::new();
-----+            if ProcessedTransactions::<T>::contains_key(&payload) {
-----+                log::info!(
-----+                    "Transaction with payload {:?} is already processed",
-----+                    payload
-----+                );
-----+                return Ok(());
-----+            }
----- 
------            // for url in urls {
------            //     let response = Self::fetch_data(&format!("{}/list_all_events", url))?;
------            //     let events: Vec<CustomEvent> =
------            //         serde_json::from_slice(&response).map_err(|_| <Error<T>>::HttpFetchingError)?;
------            //     all_events.extend(events);
------            // }
-----+            if PendingEvents::<T>::contains_key(event_id) {
-----+                log::info!("Event {} is already being processed", event_id);
-----+                return Ok(());
-----+            }
----- 
------            all_events
------        }
-----+            PendingEvents::<T>::insert(event_id, ());
----- 
------        fn finalize_transactions(validated_events: Vec<CustomEvent>) {
------            for event in validated_events {
------                Self::store_event_in_mempool(event);
------            }
------        }
-----+            // // Sign the payload
-----+            let signature = Self::sign_payload(&payload).map_err(|e| {
-----+                log::error!("Failed to sign payload: {}", e);
-----+                e
-----+            })?;
----- 
------        // Step 4: Message Validation
------        fn validate_and_process_event(event: CustomEvent) -> Result<(), Error<T>> {
------            // Validate the event data
------            if event.timestamp == 0 || event.block_height == 0 {
------                return Err(Error::<T>::InvalidEventData);
------            }
-----+            log::info!("Payload signature: {:?}", signature);
----- 
------            if event.data.is_empty() {
------                return Err(Error::<T>::InvalidEventData);
------            }
-----+            let call = Call::submit_encoded_payload {
-----+                payload: payload.clone(),
-----+            };
----- 
------            // Process the event (e.g., store in mempool)
------            Self::store_event_in_mempool(event);
-----+            log::info!("Submitting call: {:?}", call);
----- 
-----+            match frame_system::offchain::SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into()) {
-----+        Ok(_) => {
-----+            log::info!("Transaction submitted successfully");
-----+            ProcessedTransactions::<T>::insert(payload, true);
-----+            EventStorage::<T>::remove(event_id);
-----+            PendingEvents::<T>::remove(event_id);
-----             Ok(())
-----+        },
-----+        Err(e) => {
-----+            log::error!("Failed to submit unsigned transaction: {:?}", e);
-----+            PendingEvents::<T>::remove(event_id);
-----+            Err("Failed to submit unsigned transaction")
-----         }
------
------        // Step 2: Message Storage
------        fn store_event_in_mempool(event: CustomEvent) {
------            let new_event = CustomEvent::new(
------                event.id,
------                event.data,
------                event.timestamp,
------                event.block_height,
------            );
------            EventStorage::<T>::insert(new_event.id, new_event);
-----+    }
-----         }
-----+    }
----- 
------        // Step 3: Message Processing
------        fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
------            // Fetch events from the queue using the RPC call
------            let response = Self::fetch_all_events()?;
------            let events: Vec<(CustomEvent, i32)> =
------                serde_json::from_slice(&response).map_err(|_| <Error<T>>::HttpFetchingError)?;
-----+    impl<T: Config> Pallet<T>
-----+    where
-----+        <T as pallet::Config>::ValidatorId:
-----+            Clone + Into<AccountId32> + From<<T as pallet_session::Config>::ValidatorId>,
-----+        <T as pallet_session::Config>::ValidatorId: Clone,
-----+        T::AuthorityId: AppCrypto + From<sp_core::sr25519::Public>,
-----+    {
-----+        fn sign_payload(payload: &[u8]) -> Result<Sr25519Signature, &'static str> {
-----+            log::info!("Attempting to sign payload: {:?}", payload);
----- 
------            for (event, _priority) in events {
------                Self::validate_and_process_event(event)?;
------            }
-----+            let local_keys = Self::fetch_local_keys();
-----+            log::info!("Fetched local keys: {:?}", local_keys);
----- 
------            Ok(())
-----+            if let Some(public_key) = local_keys.get(0) {
-----+                match sr25519_sign(KEY_TYPE, public_key, payload) {
-----+                    Some(signature) => {
-----+                        log::info!("Payload successfully signed: {:?}", signature);
-----+                        Ok(signature)
-----+                    }
-----+                    None => {
-----+                        log::error!("Signing failed");
-----+                        Err("Signing failed")
-----+                    }
-----+                }
-----+            } else {
-----+                log::error!("No local keys available");
-----+                Err("No local keys available")
-----+            }
-----         }
----- 
------        fn get_event(event_id: u64) -> Option<CustomEvent> {
------            Some(EventStorage::<T>::get(event_id))
-----+        pub fn authority_keys_from_seed(
-----+            s: &str,
-----+            a: AccountId,
-----+        ) -> (AccountId, AuraId, GrandpaId, ImOnlineId) {
-----+            (
-----+                a,
-----+                Self::get_from_seed::<AuraId>(s),
-----+                Self::get_from_seed::<GrandpaId>(s),
-----+                Self::get_from_seed::<ImOnlineId>(s),
-----+            )
-----         }
----- 
------        fn create_inclusion_transaction() -> Result<(), &'static str> {
------            let mut events = Vec::new();
------            for event_id in EventStorage::<T>::iter_keys() {
------                if let event = EventStorage::<T>::get(event_id) {
------                    events.push(event);
------                }
------            }
-----+        fn fetch_local_keys() -> Vec<Sr25519Public> {
-----+            let keys = sp_io::crypto::sr25519_public_keys(KEY_TYPE);
-----+            log::info!("Fetched local keys: {:?}", keys);
-----+            keys
-----+        }
----- 
------            let call = Call::<T>::submit_inclusion_transaction { events };
-----+        fn process_real_event() -> Result<Vec<u8>, Error<T>> {
-----+            const HTTP_REMOTE_REQUEST: &str = "http://127.0.0.1:5555";
-----+            const HTTP_HEADER_USER_AGENT: &str = "SubstrateOffchainWorker";
-----+            const HTTP_HEADER_CONTENT_TYPE: &str = "Content-Type";
-----+            const CONTENT_TYPE_JSON: &str = "application/json";
-----+            const FETCH_TIMEOUT_PERIOD: u64 = 3000; // in milliseconds
----- 
------            // Submit the transaction
------            // T::SubmitTransaction::submit_unsigned_transaction(call.into())
------            //     .map_err(|_| "Failed to submit transaction")?;
-----+            // Create the JSON-RPC request payload
-----+            let json_payload = serde_json::json!({
-----+                "jsonrpc": "2.0",
-----+                "method": "list_all_events",
-----+                "params": [],
-----+                "id": 1
-----+            })
-----+            .to_string()
-----+            .into_bytes();
----- 
------            Ok(())
------        }
-----+            // Initiate an external HTTP POST request
-----+            let request =
-----+                rt_offchain::http::Request::post(HTTP_REMOTE_REQUEST, vec![&json_payload])
-----+                    .add_header("User-Agent", HTTP_HEADER_USER_AGENT)
-----+                    .add_header(HTTP_HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON)
-----+                    .deadline(
-----+                        sp_io::offchain::timestamp()
-----+                            .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-----+                    )
-----+                    .send()
-----+                    .map_err(|_| <Error<T>>::HttpFetchingError)?;
-----+
-----+            let response = request
-----+                .try_wait(
-----+                    sp_io::offchain::timestamp()
-----+                        .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-----+                )
-----+                .map_err(|_| <Error<T>>::HttpFetchingError)?
-----+                .map_err(|_| <Error<T>>::HttpFetchingError)?;
----- 
------        fn synchronize_events_with_peers() -> Result<(), Error<T>> {
------            let event_ids: Vec<u64> = EventStorage::<T>::iter_keys().collect();
-----+            if response.code != 200 {
-----+                log::error!("Non-200 response code: {}", response.code);
-----+                return Err(<Error<T>>::HttpFetchingError);
-----+            }
-----+            let response_body = response.body().collect::<Vec<u8>>();
-----+            let json_string = String::from_utf8(response_body).map_err(|e| {
-----+                log::error!("Failed to parse response body as UTF-8: {:?}", e);
-----+                <Error<T>>::InvalidUtf8
-----+            })?;
-----+
-----+            log::info!("HTTP Response Body: {}", json_string);
-----+
-----+            // Parse the outer JSON-RPC response
-----+            let rpc_response: serde_json::Value =
-----+                serde_json::from_str(&json_string).map_err(|e| {
-----+                    log::error!("Failed to parse JSON-RPC response: {:?}", e);
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+
-----+            log::info!("RPC Response: {:?}", rpc_response);
-----+
-----+            // Extract the "result" field, which is a stringified JSON
-----+            let result_str = rpc_response["result"].as_str().ok_or_else(|| {
-----+                log::error!("Failed to extract result string");
-----+                <Error<T>>::InvalidResponseFormat
-----+            })?;
-----+
-----+            log::info!("Result string: {}", result_str);
-----+
-----+            let inner_response: serde_json::Value =
-----+                serde_json::from_str(result_str).map_err(|e| {
-----+                    log::error!("Failed to parse inner JSON response: {:?}", e);
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+
-----+            log::info!("Inner response: {:?}", inner_response);
-----+
-----+            // Extract the events and duplicates arrays
-----+            let events = inner_response["events"].as_array().ok_or_else(|| {
-----+                log::error!("Failed to extract events array");
-----+                <Error<T>>::InvalidResponseFormat
-----+            })?;
-----+
-----+            // let duplicates = inner_response["duplicates"].as_array().unwrap_or(&Vec::new());
-----+            let binding = Vec::new();
-----+            let duplicates = inner_response["duplicates"].as_array().unwrap_or(&binding);
-----+            log::info!("Events: {:?}", events);
-----+            log::info!("Duplicates: {:?}", duplicates);
-----+
-----+            let mut processed_events = Vec::new();
-----+            for (i, event_group) in events.iter().enumerate() {
-----+                let mut processed_group = Vec::new();
-----+                for (j, event) in event_group
-----+                    .as_array()
-----+                    .ok_or_else(|| {
-----+                        log::error!("Event group {} is not an array", i);
-----+                        <Error<T>>::InvalidResponseFormat
-----+                    })?
-----+                    .iter()
-----+                    .enumerate()
-----+                {
-----+                    if let Some(custom_event) = Self::process_event(event, i, j, "event")? {
-----+                        processed_group.push(custom_event);
-----+                    }
-----+                }
-----+                processed_events.push(processed_group);
-----+            }
----- 
------            for event_id in event_ids {
------                if let Some(event) = Self::get_event(event_id) {
------                    if !Self::validate_and_process_event(event.clone()).is_ok() {
------                        // Request the event from other workers
------                        let missing_event = Self::request_event_from_peers(event_id)?;
------                        Self::validate_and_process_event(missing_event)?;
-----+            // Process duplicates
-----+            let mut processed_duplicates = Vec::new();
-----+            for (i, duplicate_group) in duplicates.iter().enumerate() {
-----+                let mut processed_group = Vec::new();
-----+                for (j, duplicate) in duplicate_group
-----+                    .as_array()
-----+                    .ok_or_else(|| {
-----+                        log::error!("Duplicate group {} is not an array", i);
-----+                        <Error<T>>::InvalidResponseFormat
-----+                    })?
-----+                    .iter()
-----+                    .enumerate()
-----+                {
-----+                    if let Some(custom_event) = Self::process_event(duplicate, i, j, "duplicate")? {
-----+                        processed_group.push(custom_event);
-----                     }
-----                 }
-----+                processed_duplicates.push(processed_group);
-----             }
----- 
------            Ok(())
-----+            // Combine processed events and duplicates
-----+            let result = ProcessedEventResult {
-----+                events: processed_events,
-----+                duplicates: processed_duplicates,
-----+                success: true,
-----+            };
-----+
-----+            // Serialize the result back to JSON
-----+            let result_json = serde_json::to_string(&result).map_err(|e| {
-----+                log::error!("Failed to serialize processed result: {:?}", e);
-----+                <Error<T>>::JsonSerializationError
-----+            })?;
-----+
-----+            log::info!("Processed result JSON: {}", result_json);
-----+
-----+            Ok(result_json.into_bytes())
-----+        }
-----+
-----+        fn process_event(
-----+            event: &serde_json::Value,
-----+            i: usize,
-----+            j: usize,
-----+            event_type: &str,
-----+        ) -> Result<Option<CustomEvent>, Error<T>> {
-----+            log::info!("Processing {} {}.{}: {:?}", event_type, i, j, event);
-----+
-----+            if let Some(event_obj) = event.as_object() {
-----+                let id = event_obj["id"].as_u64().ok_or_else(|| {
-----+                    log::error!("Failed to extract id from {} {}.{}", event_type, i, j);
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+                let timestamp = event_obj["timestamp"].as_u64().ok_or_else(|| {
-----+                    log::error!(
-----+                        "Failed to extract timestamp from {} {}.{}",
-----+                        event_type,
-----+                        i,
-----+                        j
-----+                    );
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+                let block_height = event_obj["block_height"].as_u64().ok_or_else(|| {
-----+                    log::error!(
-----+                        "Failed to extract block_height from {} {}.{}",
-----+                        event_type,
-----+                        i,
-----+                        j
-----+                    );
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+
-----+                let data_str = event_obj["data"].as_str().ok_or_else(|| {
-----+                    log::error!(
-----+                        "Failed to extract data string from {} {}.{}",
-----+                        event_type,
-----+                        i,
-----+                        j
-----+                    );
-----+                    <Error<T>>::InvalidResponseFormat
-----+                })?;
-----+
-----+                log::info!("Data string for {} {}.{}: {}", event_type, i, j, data_str);
-----+
-----+                let data: CustomData = serde_json::from_str(data_str).map_err(|e| {
-----+                    log::error!(
-----+                        "Failed to parse {} data for {} {}.{}: {:?}",
-----+                        event_type,
-----+                        event_type,
-----+                        i,
-----+                        j,
-----+                        e
-----+                    );
-----+                    <Error<T>>::JsonSerializationError
-----+                })?;
-----+
-----+                let custom_event = CustomEvent {
-----+                    id,
-----+                    data,
-----+                    timestamp,
-----+                    block_height,
-----+                };
-----+
-----+                log::info!("Processed {} {}.{}: {:?}", event_type, i, j, custom_event);
-----+
-----+                Ok(Some(custom_event))
-----+            } else {
-----+                log::warn!(
-----+                    "Skipping non-object {} {}.{}: {:?}",
-----+                    event_type,
-----+                    i,
-----+                    j,
-----+                    event
-----+                );
-----+                Ok(None)
-----+            }
-----         }
------
------        fn request_event_from_peers(event_id: u64) -> Result<CustomEvent, Error<T>> {
------            let url = Self::construct_url(&format!("/api/events/{}", event_id));
------            let response = Self::fetch_data(&url).map_err(|_| <Error<T>>::HttpFetchingError)?;
------
------            let event: CustomEvent =
------                serde_json::from_slice(&response).map_err(|_| <Error<T>>::HttpFetchingError)?;
------
------            Ok(event)
-----+        // Step 5: Message Cleanup
-----+        fn cleanup_processed_events() {
-----+            // Remove events from storage that have been included in the blockchain
-----+            for (event_id, _) in EventStorage::<T>::iter() {
-----+                EventStorage::<T>::remove(event_id);
-----+            }
-----         }
----- 
------        fn construct_url(path: &str) -> String {
------            const DEFAULT_HOST: &str = "http://scrolls-1";
------            const DEFAULT_PORT: &str = "4123";
-----+        // fn fetch_local_keys() -> Vec<T::AuthorityId> {
-----+        //     let key_type_id = T::AuthorityId::ID;
-----+        //     sp_io::crypto::sr25519_public_keys(key_type_id)
-----+        //         .into_iter()
-----+        //         .map(|key| T::AuthorityId::from(key))
-----+        //         .collect()
-----+        // }
-----+        // Define the required modules and types
-----+        pub fn get_from_seed<TPublic: Public>(seed: &str) -> <TPublic::Pair as Pair>::Public {
-----+            TPublic::Pair::from_string(&format!("//{}", seed), None)
-----+                .expect("static values are valid; qed")
-----+                .public()
-----+        }
----- 
------            format!("{}:{}{}", DEFAULT_HOST, DEFAULT_PORT, path)
-----+        pub fn get_account_id_from_seed<TPublic: Public>(seed: &str) -> AccountId
-----+        where
-----+            <Signature as sp_runtime::traits::Verify>::Signer:
-----+                From<<TPublic::Pair as Pair>::Public>,
-----+        {
-----+            <Signature as sp_runtime::traits::Verify>::Signer::from(Self::get_from_seed::<TPublic>(
-----+                seed,
-----+            ))
-----+            .into_account()
-----         }
----- 
------        fn fetch_and_process_data() -> Result<(), &'static str> {
------            // Example: Fetch data from multiple endpoints
------            let assets_url = Self::construct_url("/api/info/address/stake/assets/");
------            // Self::fetch_data(&assets_url)?;
-----+        // Function to convert ValidatorId to AuthorityId
-----+        fn convert_validator_id_to_authority_id(
-----+            key: <T as pallet::Config>::ValidatorId,
-----+        ) -> Result<T::AuthorityId, &'static str> {
-----+            // Convert ValidatorId to AccountId32
-----+            let account_id32: AccountId32 = key.into();
----- 
------            // let pools_url = Self::construct_url("/api/info/pools/1"); // example with page number
------            // Self::fetch_data(&pools_url)?;
-----+            // Retrieve the public keys and find the matching one
-----+            let public_key = sp_io::crypto::sr25519_public_keys(T::AuthorityId::ID)
-----+                .into_iter()
-----+                .find(|pk| AccountId32::from(*pk) == account_id32)
-----+                .ok_or("Failed to find AuthorityId for the given ValidatorId")?;
----- 
------            Ok(())
-----+            // Convert the public key to AuthorityId
-----+            Ok(T::AuthorityId::from(public_key))
-----         }
----- 
------        fn process_stored_data(storage_key: &[u8]) -> Result<(), &'static str> {
------            if let Some(data) = sp_io::offchain::local_storage_get(
------                sp_runtime::offchain::StorageKind::PERSISTENT,
------                storage_key,
------            ) {
------                let assets: Vec<Asset> =
------                    serde_json::from_slice(&data).map_err(|_| "Failed to parse JSON data")?;
-----+        // Function to convert AuthorityId to AccountId32
-----+        fn convert_to_account_id32(key: T::AuthorityId) -> AccountId32 {
-----+            let public_key = key.to_raw_vec();
-----+            AccountId32::from_slice(&public_key)
-----+                .expect("Failed to convert AuthorityId to AccountId32")
-----+        }
----- 
------                for asset in assets {
------                    log::info!("Asset ID: {}, Quantity: {}", asset.asset_id, asset.quantity);
-----+        fn is_leader() -> bool {
-----+            // Fetch the current set of validators
-----+            let validators = validator_set::Validators::<T>::get();
-----+            // Get the current session index
-----+            let current_index = pallet_session::Pallet::<T>::current_index();
-----+
-----+            if let Some(session_leader) = validators.get(current_index as usize % validators.len())
-----+            {
-----+                // // Convert session's ValidatorId to pallet's ValidatorId
-----+                let leader = Self::convert_session_validator_id_to_pallet_validator_id(
-----+                    session_leader.clone(),
-----+                );
-----+
-----+                // // Convert leader to AuthorityId
-----+                if let Ok(leader_authority_id) = Self::convert_validator_id_to_authority_id(leader)
-----+                {
-----+                    let local_keys = Self::fetch_local_keys();
-----+
-----+                    for local_key in local_keys {
-----+                        if local_key == leader_authority_id.clone().into() {
-----+                            return true;
-----+                        }
-----+                    }
-----                 }
-----             }
------            Ok(())
-----+            false
-----         }
-----+        // Step 4: Message Validation
-----+        fn validate_and_process_event(event: CustomEvent) -> Result<(), Error<T>> {
-----+            // Validate the event data
-----+            if event.timestamp == 0 || event.block_height == 0 {
-----+                return Err(Error::<T>::InvalidEventData);
-----+            }
----- 
------        fn fetch_data(url: &str) -> Result<Vec<u8>, &'static str> {
------            const FETCH_TIMEOUT_PERIOD: u64 = 3000; // in milliseconds
------            let request = rt_offchain::http::Request::get(url);
------
------            let timeout = sp_io::offchain::timestamp()
------                .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD));
------
------            let pending = request
------                .deadline(timeout)
------                .send()
------                .map_err(|_| "Failed to send request")?;
------
------            let response = pending
------                .try_wait(timeout)
------                .map_err(|_| "Timeout while waiting for response")?
------                .map_err(|_| "Failed to receive response")?;
------
------            if response.code != 200 {
------                log::error!("Unexpected status code: {}", response.code);
------                return Err("Non-200 status code returned from API");
-----+            // Check if the data is empty (you might want to adjust this condition based on your needs)
-----+            if event.data.event_type.is_empty() {
-----+                return Err(Error::<T>::InvalidEventData);
-----             }
----- 
------            let body = response.body().collect::<Vec<u8>>();
------            log::info!("Response body: {:?}", body);
-----+            // Process the event (e.g., store in mempool)
-----+            Self::store_event_in_mempool(event.clone()).map_err(|_| Error::<T>::StorageOverflow)?;
----- 
------            Ok(body)
------        }
-----+            // Encode the event payload
-----+            let payload = event.encode();
----- 
------        fn fetch_address_stake_assets() -> Result<(), &'static str> {
------            let url = Self::construct_url("/api/info/address/stake/assets/");
------            // let data = Self::fetch_data(&url)?;
------            // process_address_stake_assets(data)
------            Ok(())
------        }
-----+            // Submit the encoded payload as an unsigned transaction
-----+            log::info!(
-----+                "Submitting unsigned transaction with payload: {:?}",
-----+                payload
-----+            );
----- 
------        fn fetch_addresses_assets() -> Result<(), &'static str> {
------            let url = Self::construct_url("/api/info/addresses/assets/");
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
-----             Ok(())
-----         }
----- 
------        fn fetch_pools(page: u32) -> Result<(), &'static str> {
------            let url = Self::construct_url(&format!("/api/info/pools/{}", page));
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
-----+        // Step 2: Message Storage
-----+        fn store_event_in_mempool(event: CustomEvent) -> Result<(), &'static str> {
-----+            EventStorage::<T>::insert(event.id, event);
-----             Ok(())
-----         }
----- 
------        fn fetch_token_nft_status() -> Result<(), &'static str> {
------            let url = Self::construct_url("/api/info/tokens/isNft/");
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
------            Ok(())
------        }
-----+        fn remove_event_from_priority_queue(event_id: u64) -> Result<(), Error<T>> {
-----+            let remove_event_payload = serde_json::json!({
-----+                "jsonrpc": "2.0",
-----+                "method": "remove_event",
-----+                "params": [event_id],
-----+                "id": 1
-----+            })
-----+            .to_string()
-----+            .into_bytes();
-----+            let remove_event_payload_ref: Vec<&[u8]> = vec![&remove_event_payload];
----- 
------        fn fetch_epoch_stake_amount(stake_addr: &str, epoch: u32) -> Result<(), &'static str> {
------            let url = Self::construct_url(&format!(
------                "/api/info/epoch/stake/amount/{}/{}",
------                stake_addr, epoch
------            ));
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
------            Ok(())
------        }
-----+            const HTTP_REMOTE_REQUEST: &str = "http://127.0.0.1:5555";
-----+            const HTTP_HEADER_USER_AGENT: &str = "SubstrateOffchainWorker";
-----+            const HTTP_HEADER_CONTENT_TYPE: &str = "Content-Type";
-----+            const CONTENT_TYPE_JSON: &str = "application/json";
-----+            const FETCH_TIMEOUT_PERIOD: u64 = 5000; // in milliseconds
-----+
-----+            let request =
-----+                rt_offchain::http::Request::post(HTTP_REMOTE_REQUEST, remove_event_payload_ref)
-----+                    .add_header("User-Agent", HTTP_HEADER_USER_AGENT)
-----+                    .add_header(HTTP_HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON)
-----+                    .deadline(
-----+                        sp_io::offchain::timestamp()
-----+                            .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-----+                    )
-----+                    .send()
-----+                    .map_err(|_| <Error<T>>::HttpFetchingError)?;
-----+
-----+            let response = request
-----+                .try_wait(
-----+                    sp_io::offchain::timestamp()
-----+                        .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-----+                )
-----+                .map_err(|_| <Error<T>>::HttpFetchingError)?
-----+                .map_err(|_| <Error<T>>::HttpFetchingError)?;
----- 
------        fn fetch_reward_amount(stake_addr: &str) -> Result<(), &'static str> {
------            let url = Self::construct_url(&format!("/api/info/reward/amount/{}", stake_addr));
------            // let data = Self::fetch_data(&url)?;
------            // Process data as needed
------            Ok(())
------        }
-----+            log::info!("Response code: {}", response.code);
-----+
-----+            let body = response.body().collect::<Vec<u8>>();
-----+            match String::from_utf8(body.clone()) {
-----+                Ok(json_string) => {
-----+                    log::info!("Response body: {}", json_string);
-----+                }
-----+                Err(e) => {
-----+                    log::error!("Failed to parse response body as UTF-8: {:?}", e);
-----+                    log::info!("Response body bytes: {:?}", body);
-----+                }
-----+            }
----- 
------        fn fetch_epoch_changes(from_epoch: u32, to_epoch: u32) -> Result<(), &'static str> {
------            let url = Self::construct_url(&format!(
------                "/api/aya/epoch/change/from/{}/{}",
------                from_epoch, to_epoch
------            ));
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
-----             Ok(())
-----         }
----- 
------        fn fetch_latest_epoch_change() -> Result<(), &'static str> {
------            let url = Self::construct_url("/api/aya/epoch/change/latest");
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
------            Ok(())
-----+        fn is_duplicate(event: &CustomEvent) -> bool {
-----+            ProcessedEvents::<T>::contains_key(event.id)
-----         }
----- 
------        fn fetch_current_epoch() -> Result<(), &'static str> {
------            let url = Self::construct_url("/api/aya/epoch/current/");
------            // let data = Self::fetch_data(&url)?;
------            // save to local storage queue
------            Ok(())
-----+        fn get_event(event_id: u64) -> Option<CustomEvent> {
-----+            Some(EventStorage::<T>::get(event_id))
-----         }
-----+        // Use structured logging for better clarity in logs.
-----+        fn log_event_processing(event: &CustomEvent) {
-----+            log::info!(
-----+                target: "event_processing",
-----+                "Processing event: id={}, timestamp={}, block_height={}",
-----+                event.id, event.timestamp, event.block_height
-----+            );
-----+        }
-----+    }
----- 
------        fn verify_event_sequence(events: &[CustomEvent]) -> Result<(), &'static str> {
------            // Implement logic to verify the sequence and order of events
------            // This function should compare events with the local mempool or state
------            for i in 1..events.len() {
------                // TODO: Implement sequence verification logic
-----+    // Add more descriptive error messages to help with debugging.
-----+    impl<T: Config> Pallet<T> {
-----+        fn error_description(error: &Error<T>) -> &'static str {
-----+            match error {
-----+                Error::HttpFetchingError => "HTTP request failed",
-----+                Error::InvalidUtf8 => "UTF-8 conversion error",
-----+                Error::InvalidResponseFormat => "Response format is incorrect",
-----+                Error::JsonSerializationError => "Error serializing or deserializing JSON",
-----+                Error::InvalidEventData => "Event data validation failed",
-----+                _ => "Unknown error",
-----             }
------            Ok(())
-----         }
-----     }
----- 
------    use scale_info::prelude::string::String;
------
-----     #[derive(Deserialize, Debug)]
-----     struct Asset {
-----         // Define the expected fields
-----@@ -498,37 +875,104 @@ pub mod pallet {
-----         }
-----     }
----- 
------    #[pallet::call]
-----     impl<T: Config> Pallet<T> {
------        #[pallet::weight(10_000)]
------        pub fn manual_fetch(origin: OriginFor<T>) -> DispatchResult {
------            ensure_signed(origin)?;
-----+        fn process_decoded_call(call: Call<T>) -> DispatchResult {
-----+            match call {
-----+                Call::process_registration_event { nonce, payload } => {
-----+                    log::info!("Processing decoded call with nonce: {}", nonce);
----- 
------            // Fetch and process data from the priority queue
------            match Self::fetch_and_process_events_from_queue() {
------                Ok(_) => {
------                    Self::deposit_event(Event::DataFetchedSuccessfully);
-----                     Ok(())
-----                 }
------                Err(e) => {
------                    log::error!("Error in manual fetch: {:?}", e);
------                    Err(Error::<T>::HttpFetchingError.into())
------                }
-----+                _ => Err(Error::<T>::InvalidCall.into()),
-----             }
-----         }
-----+    }
----- 
-----+    #[pallet::call]
-----+    impl<T: Config> Pallet<T> {
-----+        #[pallet::call_index(0)]
-----         #[pallet::weight(10_000)]
------        pub fn submit_inclusion_transaction(
-----+        pub fn manual_fetch(origin: OriginFor<T>) -> DispatchResult {
-----+            ensure_signed(origin)?;
-----+
-----+            // // Fetch and process data from the priority queue
-----+            // match Self::fetch_and_process_events_from_queue() {
-----+            //     Ok(_) => {
-----+            //         Self::deposit_event(Event::DataFetchedSuccessfully);
-----+            //         Ok(())
-----+            //     }
-----+            //     Err(e) => {
-----+            //         log::error!("Error in manual fetch: {:?}", e);
-----+            //         Err(Error::<T>::HttpFetchingError.into())
-----+            //     }
-----+            // }
-----+            Ok(())
-----+        }
-----+        #[pallet::call_index(1)]
-----+        #[pallet::weight(10_000)]
-----+        pub fn process_registration_event(
-----             origin: OriginFor<T>,
------            events: Vec<CustomEvent>,
-----+            nonce: u64,
-----+            payload: Vec<u8>,
-----         ) -> DispatchResult {
------            // Ensure the call is unsigned to allow offchain workers to submit
-----+            let _who = ensure_signed(origin)?;
-----+            log::info!("Received payload: {:?}", payload);
-----+
-----+            // Decode the payload using SCALE codec
-----+            let decoded_payload = CustomEvent::decode(&mut &payload[..]).map_err(|e| {
-----+                log::error!("Failed to decode payload: {:?}", e);
-----+                Error::<T>::InvalidPayload
-----+            })?;
-----+
-----+            log::info!("Decoded payload: {:?}", decoded_payload);
-----+
-----+            // Process the payload as needed
-----+            Ok(())
-----+        }
-----+        #[pallet::call_index(2)]
-----+        #[pallet::weight(10_000)]
-----+        pub fn submit_encoded_payload(origin: OriginFor<T>, payload: Vec<u8>) -> DispatchResult {
-----+            log::info!("submit_encoded_payload called with payload: {:?}", payload);
-----+
-----             let _who = ensure_none(origin)?;
------            // Verify event sequence and order with committee
------            Self::verify_event_sequence(&events)?;
------            // Logic to handle the inclusion of events in the transaction
------            // Validate events, ensure proper ordering, etc.
----- 
-----+            // Decode the payload
-----+            let call: Call<T> = Decode::decode(&mut &payload[..]).map_err(|e| {
-----+                log::error!("Failed to decode payload: {:?}", e);
-----+                Error::<T>::InvalidPayload
-----+            })?;
-----+
-----+            // Process the decoded call
-----+            log::info!("Processing decoded call: {:?}", call);
-----+            Self::process_decoded_call(call)
-----+        }
-----+        #[pallet::call_index(3)]
-----+        #[pallet::weight(10_000)]
-----+        pub fn remove_event_from_storage(origin: OriginFor<T>, event_id: u64) -> DispatchResult {
-----+            let _who = ensure_signed(origin)?;
-----+            ensure!(
-----+                EventStorage::<T>::contains_key(event_id),
-----+                Error::<T>::EventNotFound
-----+            );
-----+
-----+            EventStorage::<T>::remove(event_id);
-----+
-----+            Self::deposit_event(Event::EventRemoved { event_id });
-----+            Ok(())
-----+        }
-----+        #[pallet::call_index(4)]
-----+        #[pallet::weight(10_000)]
-----+        pub fn store_event_id(origin: OriginFor<T>, event_id: String) -> DispatchResult {
-----+            let _who = ensure_none(origin)?;
-----+            // Implement the logic to store the event ID
-----+            log::info!("Storing event ID: {:?}", event_id);
-----+            Ok(())
-----+        }
-----+        #[pallet::weight(10_000)]
-----+        pub fn do_something(origin: OriginFor<T>, param: u32) -> DispatchResult {
-----+            let who = ensure_signed(origin)?;
-----+            // Logic for the call
-----+            Self::deposit_event(Event::SomethingDone { param });
-----             Ok(())
-----         }
-----     }
-----@@ -540,12 +984,21 @@ pub mod pallet {
-----         InvalidEventData,
-----         EventNotFound,
-----         HttpFetchingError,
-----+        InvalidPayload,
-----+        InvalidCall,
-----+        InvalidResponseFormat,
-----+        InvalidUtf8,
-----+        TransactionSubmissionError,
-----+        NoEventsInQueue,
-----+        JsonSerializationError,
-----     }
----- 
-----     #[pallet::event]
-----     #[pallet::generate_deposit(pub(super) fn deposit_event)]
-----     pub enum Event<T: Config> {
-----         DataFetchedSuccessfully,
-----+        EventRemoved { event_id: u64 },
-----+        SomethingDone { param: u32 },
-----     }
----- 
-----     #[pallet::type_value]
-----@@ -557,9 +1010,6 @@ pub mod pallet {
-----         fn some_extrinsic() -> Weight {
-----             Weight::zero()
-----         }
------        // fn add_validator() -> Weight;
------        // fn remove_validator() -> Weight;
------        // fn register_validator() -> Weight;
-----     }
----- 
-----     impl WeightInfo for () {
-----diff --git a/pallets/pallet-registration/src/limits.rs b/pallets/pallet-registration/src/limits.rs
-----index 755edec..cbe2d98 100644
-------- a/pallets/pallet-registration/src/limits.rs
-----+++ b/pallets/pallet-registration/src/limits.rs
-----@@ -1,18 +1,57 @@
------use crate::types::NFTMintData;
-----+// limits.rs
----- use frame_support::pallet_prelude::Get;
----- use frame_support::pallet_prelude::MaxEncodedLen;
----- 
------pub struct MaxNFTMintDataLength;
------impl Get<u32> for MaxNFTMintDataLength {
------    fn get() -> u32 {
------        1024 // Adjust this value as needed
-----+use crate::types::CustomData;
-----+use crate::types::CustomEvent;
-----+use crate::types::EpochChangeData;
-----+
-----+pub struct MaxDataLength;
-----+
-----+impl MaxEncodedLen for CustomEvent {
-----+    fn max_encoded_len() -> usize {
-----+        u32::MAX as usize
-----+    }
-----+}
-----+
-----+impl MaxEncodedLen for CustomData {
-----+    fn max_encoded_len() -> usize {
-----+        u32::MAX as usize
-----     }
----- }
----- 
------impl MaxEncodedLen for NFTMintData {
-----+impl MaxEncodedLen for EpochChangeData {
-----     fn max_encoded_len() -> usize {
------        // Calculate the maximum encoded length of NFTMintData
------        // This is an estimate; adjust according to your actual data structure
------        1024
-----+        u32::MAX as usize
-----+    }
-----+}
-----+
-----+impl Get<u32> for MaxDataLength {
-----+    fn get() -> u32 {
-----+        1024 // Define your max length here
-----+    }
-----+}
-----+
-----+pub struct MaxPayloadLength;
-----+
-----+impl Get<u32> for MaxPayloadLength {
-----+    fn get() -> u32 {
-----+        1024 // Define your max length here
-----+    }
-----+}
-----+
-----+pub struct MaxEventsLength;
-----+
-----+impl Get<u32> for MaxEventsLength {
-----+    fn get() -> u32 {
-----+        100 // Define your max length here
-----+    }
-----+}
-----+
-----+pub struct MaxRemoveEventsLength;
-----+
-----+impl Get<u32> for MaxRemoveEventsLength {
-----+    fn get() -> u32 {
-----+        100 // Define your max length here
-----     }
----- }
-----diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
-----index b655376..caef2a2 100644
-------- a/pallets/pallet-registration/src/mock.rs
-----+++ b/pallets/pallet-registration/src/mock.rs
-----@@ -1,10 +1,12 @@
----- #![cfg_attr(not(feature = "std"), no_std)]
----- 
------use crate::{CustomData, CustomEvent, EventType};
-----+use crate::{CustomData, CustomEvent};
----- use frame_support::{
-----     construct_runtime, parameter_types,
-----     traits::{ConstU32, ConstU64, Everything, PalletInfo as FramePalletInfo},
----- };
-----+use frame_system::offchain::SendTransactionTypes;
-----+use crate as pallet_registration;
----- use frame_system as system;
----- use scale_info::TypeInfo;
----- use serde::{Deserialize, Serialize};
-----@@ -40,12 +42,38 @@ impl From<u64> for MyAccountId {
-----     }
----- }
----- 
------impl From<AccountId32> for MyAccountId {
------    fn from(account: AccountId32) -> Self {
------        MockAccountId32Convert::into_account_id(account)
-----+
-----+impl From<MyAccountId> for sp_runtime::AccountId32 {
-----+    fn from(account: MyAccountId) -> Self {
-----+        let mut bytes = [0u8; 32];
-----+        bytes[0..8].copy_from_slice(&account.0.to_le_bytes());
-----+        Self::new(bytes)
-----+    }
-----+}
-----+
-----+impl From<sp_runtime::AccountId32> for MyAccountId {
-----+    fn from(account: sp_runtime::AccountId32) -> Self {
-----+        let bytes: &[u8] = account.as_ref();
-----+        let value = u64::from_le_bytes(bytes[0..8].try_into().unwrap());
-----+        MyAccountId(value)
-----+    }
-----+}
-----+
-----+impl IdentifyAccount for TestAccountPublic {
-----+    type AccountId = MyAccountId;
-----+
-----+    fn into_account(self) -> Self::AccountId {
-----+        MyAccountId(0) // Replace with actual logic if needed
-----+    }
-----+}
-----+
-----+impl From<sr25519::Public> for TestAccountPublic {
-----+    fn from(pub_key: sr25519::Public) -> Self {
-----+        TestAccountPublic(pub_key)
-----     }
----- }
----- 
-----+
----- pub struct MockAccountId32Convert;
----- 
----- impl MockAccountId32Convert {
-----@@ -105,8 +133,7 @@ impl frame_system::Config for Test {
----- }
----- 
----- parameter_types! {
------    pub const EpochDuration: u64 = 10;
------    pub const MinEpochLength: u64 = 5;
-----+   
-----     pub static Validators: Vec<u64> = vec![1, 2, 3];
-----     pub static NextValidators: Vec<u64> = vec![1, 2, 3];
-----     pub static Authorities: Vec<UintAuthorityId> = vec![UintAuthorityId(1), UintAuthorityId(2), UintAuthorityId(3)];
-----@@ -132,6 +159,12 @@ impl pallet_session::Config for Test {
-----     type WeightInfo = ();
----- }
----- 
-----+type UncheckedExtrinsic = sp_runtime::generic::UncheckedExtrinsic<
-----+    u64,
-----+    RuntimeCall,
-----+    MultiSignature,
-----+    frame_system::CheckNonce<Test>,
-----+>;
----- pub struct TestShouldEndSession;
----- 
----- impl pallet_session::ShouldEndSession<u64> for TestShouldEndSession {
-----@@ -173,12 +206,127 @@ construct_runtime!(
-----         System: frame_system,
-----         ValidatorSet: substrate_validator_set,
-----         Session: pallet_session,
-----+        Registration: pallet_registration,
-----     }
----- );
----- 
------impl From<MyAccountId> for AccountId32 {
-----+
-----+
-----+
-----+
-----+impl pallet_registration::Config for Test {
-----+    type RuntimeEvent = RuntimeEvent;
-----+    type WeightInfo = ();
-----+    type AuthorityId = AuraId;
-----+    type ValidatorId = MyAccountId;
-----+    type AccountId32Convert = MockAccountId32Convert;
-----+    type Call = RuntimeCall;
-----+    type UnsignedPriority = frame_support::traits::ConstU64<100>;
-----+}
-----+
-----+impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Test
-----+where
-----+    RuntimeCall: From<LocalCall>,
-----+    LocalCall: Clone + Encode + Decode + PartialEq + Eq,
-----+{
-----+    fn create_transaction<C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>>(
-----+        call: Self::RuntimeCall,
-----+        public: Self::Public,
-----+        account: Self::AccountId,
-----+        nonce: Self::Nonce,
-----+    ) -> Option<(
-----+        Self::RuntimeCall,
-----+        <Self::Extrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload,
-----+    )> {
-----+        let period = BlockHashCount::get()
-----+            .checked_next_power_of_two()
-----+            .map(|c| c / 2)
-----+            .unwrap_or(2) as u64;
-----+        let current_block = System::block_number()
-----+            .saturated_into::<u64>()
-----+            .saturating_sub(1);
-----+        let era = Era::mortal(period, current_block);
-----+        let extra = (frame_system::CheckNonce::<Test>::from(nonce),);
-----+        let raw_payload = SignedPayload::new(call, extra)
-----+            .map_err(|e| {
-----+                log::warn!("Unable to create signed payload: {:?}", e);
-----+            })
-----+            .ok()?;
-----+        let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;
-----+        let address = account;
-----+        let (call, extra, _) = raw_payload.deconstruct();
-----+
-----+        Some((call, (address.into(), signature.into(), extra.0)))
-----+    }
-----+}
-----+
-----+impl<LocalCall> frame_system::offchain::SendTransactionTypes<LocalCall> for Test
-----+where
-----+    RuntimeCall: From<LocalCall>,
-----+{
-----+    type OverarchingCall = RuntimeCall;
-----+    type Extrinsic = UncheckedExtrinsic;
-----+}
-----+
-----+#[derive(
-----+    Clone,
-----+    PartialEq,
-----+    Eq,
-----+    Debug,
-----+    TypeInfo,
-----+    Encode,
-----+    Decode,
-----+    MaxEncodedLen,
-----+    Serialize,
-----+    Deserialize,
-----+    Ord,
-----+    PartialOrd,
-----+)]
-----+pub struct TestAccountPublic(sr25519::Public);
-----+
-----+
-----+impl Default for TestAccountPublic {
-----+    fn default() -> Self {
-----+        TestAccountPublic(sr25519::Public::from_raw([0u8; 32]))
-----+    }
-----+}
-----+
-----+impl RuntimeAppPublic for TestAccountPublic {
-----+    type Signature = sr25519::Signature;
-----+
-----+    fn all() -> Vec<Self> {
-----+        vec![Self::default()]
-----+    }
-----+
-----+    fn generate_pair(seed: Option<Vec<u8>>) -> Self {
-----+        sr25519::Public::generate_pair(KeyTypeId(*b"test"), seed).into()
-----+    }
-----+
-----+    fn sign<M: AsRef<[u8]>>(&self, msg: &M) -> Option<Self::Signature> {
-----+        Some(sr25519::Pair::from_seed(&[0u8; 32]).sign(msg.as_ref()))
-----+    }
-----+
-----+    const ID: KeyTypeId = KeyTypeId(*b"test");
-----+
-----+    fn verify<M: AsRef<[u8]>>(&self, msg: &M, signature: &Self::Signature) -> bool {
-----+        signature.verify(msg.as_ref(), &self.0)
-----+    }
-----+
-----+    fn to_raw_vec(&self) -> sp_application_crypto::Vec<u8> {
-----+        self.0.to_vec()
-----+    }
-----+}
-----+
-----+impl frame_system::offchain::SigningTypes for Test {
-----+    type Public = TestAccountPublic;
-----+    type Signature = sr25519::Signature;
-----+}
-----+
-----+
-----+
-----+impl From<MyAccountId> for u64 {
-----     fn from(account: MyAccountId) -> Self {
------        AccountId32::new([0; 32])
-----+        account.0
-----     }
----- }
----- 
-----diff --git a/pallets/pallet-registration/src/types.rs b/pallets/pallet-registration/src/types.rs
-----index 7760150..344dd7c 100644
-------- a/pallets/pallet-registration/src/types.rs
-----+++ b/pallets/pallet-registration/src/types.rs
-----@@ -1,5 +1,4 @@
----- use alloc::string::String;
------use scale_codec::WrapperTypeEncode;
----- use scale_info::TypeInfo;
----- use serde::{Deserialize, Serialize};
----- use sp_io::hashing::blake2_256;
-----@@ -8,45 +7,17 @@ use sp_runtime::traits::BlakeTwo256;
----- use sp_runtime::traits::Hash;
----- use sp_std::prelude::*;
----- 
------/// EventType Enum to distinguish between different types of events
------#[derive(
------    Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
------)]
------pub enum EventType {
------    #[default]
------    // EpochChange,
------    NFTMint,
------}
------
------/// CustomEvent struct for holding event data
----- #[derive(
-----     Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
----- )]
----- pub struct CustomEvent {
-----     pub id: u64,
------    pub event_type: EventType,
-----     pub data: CustomData,
-----     pub timestamp: u64,
-----     pub block_height: u64,
----- }
----- 
----- impl CustomEvent {
------    pub fn new(
------        id: u64,
------        event_type: EventType,
------        data: CustomData,
------        timestamp: u64,
------        block_height: u64,
------    ) -> Self {
------        CustomEvent {
------            id,
------            event_type,
------            data,
------            timestamp,
------            block_height,
------        }
------    }
------
-----     pub fn is_valid(&self) -> bool {
-----         self.timestamp != 0 && self.block_height != 0
-----     }
-----@@ -59,20 +30,19 @@ impl CustomEvent {
-----     }
----- 
-----     pub fn hash(&self) -> [u8; 32] {
------        let mut encoded_data = self.event_type.encode();
-----+        let mut encoded_data = self.data.event_type.encode();
-----         encoded_data.extend(self.data.encode());
-----         blake2_256(&encoded_data)
-----     }
----- }
----- 
------/// CustomData struct for holding event-specific data
----- #[derive(
-----     Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
----- )]
----- pub struct CustomData {
-----     #[serde(rename = "type")]
-----     pub event_type: String,
------    pub data: EventData,
-----+    pub data: EpochChangeData,
----- }
----- 
----- impl CustomData {
-----@@ -83,21 +53,9 @@ impl CustomData {
-----     }
----- }
----- 
------/// EventData Enum to hold specific event data
------#[derive(Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo)]
------pub enum EventData {
------    EpochChange(EpochChangeData),
------    NFTMint(NFTMintData),
------}
------
------impl Default for EventData {
------    fn default() -> Self {
------        EventData::NFTMint(NFTMintData::default())
------    }
------}
------
------/// EpochChangeData struct for holding data specific to EpochChange events
------#[derive(Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo)]
-----+#[derive(
-----+    Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
-----+)]
----- pub struct EpochChangeData {
-----     pub last_epoch: u64,
-----     pub last_blockhash: String,
-----@@ -124,41 +82,3 @@ impl EpochChangeData {
-----         blake2_256(&encoded_data)
-----     }
----- }
------
------impl Default for EpochChangeData {
------    fn default() -> Self {
------        EpochChangeData {
------            last_epoch: 0,
------            last_blockhash: "".to_string(),
------            last_slot: 0,
------            new_epoch: 0,
------            new_slot: 0,
------            new_blockhash: "".to_string(),
------            epoch_nonce: "".to_string(),
------            extra_entropy: None,
------        }
------    }
------}
------
------/// NFTMintData struct for holding data specific to NFTMint events
------#[derive(
------    Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
------)]
------pub struct NFTMintData {
------    pub tx_hash: String,
------    pub tx_slot: u64,
------    pub nft_policy_id: String,
------    pub nft_asset_name: String,
------    pub recipient_address: String,
------}
------
------impl NFTMintData {
------    pub fn hash(&self) -> [u8; 32] {
------        let mut encoded_data = self.tx_hash.encode();
------        encoded_data.extend(self.tx_slot.encode());
------        encoded_data.extend(self.nft_policy_id.encode());
------        encoded_data.extend(self.nft_asset_name.encode());
------        encoded_data.extend(self.recipient_address.encode());
------        blake2_256(&encoded_data)
------    }
------}
----diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
----index 261370f..950eecc 100644
------- a/pallets/pallet-registration/src/lib.rs
----+++ b/pallets/pallet-registration/src/lib.rs
----@@ -66,7 +66,7 @@ pub mod weights;
---- mod limits;
---- pub mod types;
---- use limits::{MaxDataLength, MaxEventsLength, MaxPayloadLength, MaxRemoveEventsLength};
-----use types::{CustomData, CustomEvent, EpochChangeData};
----+use types::{CustomData, CustomEvent, RegistrationData};
---- 
---- use sp_core::ecdsa::{Pair as EcdsaPair, Public as EcdsaPublic, Signature as EcdsaSignature};
---- use sp_core::Pair;
----@@ -266,41 +266,42 @@ pub mod pallet {
----             Err(<Error<T>>::InvalidResponseFormat)
----         }
----         fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
-----            log::info!("Fetching all events from the queue");
----+            log::info!("Starting to fetch and process events");
---- 
----             let response = Self::process_real_event()?;
----+            log::info!("Received response from process_real_event");
----+
----             let response_data: ProcessedEventResult =
----                 serde_json::from_slice(&response).map_err(|e| {
----                     log::error!("Failed to deserialize events: {:?}", e);
----                     <Error<T>>::JsonSerializationError
----                 })?;
---- 
-----            let events = response_data.events;
-----            let duplicates = response_data.duplicates;
----+            log::info!("Deserialized {} events", response_data.events.len());
---- 
-----            for event_group in events.into_iter() {
-----                for event in event_group {
-----                    log::info!("Processing event: {:?}", event);
----+            for (i, event_group) in response_data.events.into_iter().enumerate() {
----+                for (j, event) in event_group.into_iter().enumerate() {
----+                    log::info!("Processing event {}.{}: {:?}", i, j, event);
---- 
-----                    // Check if the event has already been processed
----                     if ProcessedEvents::<T>::contains_key(event.id) {
----                         log::info!("Event {} is already processed", event.id);
-----                        Self::remove_event_from_priority_queue(event.id).ok(); // Ensure to remove already processed events
----+                        Self::remove_event_from_priority_queue(event.id).ok();
----                         continue;
----                     }
---- 
----                     let payload = event.encode();
----                     if !ProcessedTransactions::<T>::contains_key(&payload) {
-----                        log::info!("Attempting to submit unsigned transaction with payload: {:?} and event_id: {}", payload, event.id);
----+                        log::info!("Submitting transaction for event {}", event.id);
----                         match Self::submit_unsigned_transaction(payload.clone(), event.id) {
----                             Ok(_) => {
----                                 log::info!(
----                                     "Transaction submitted successfully for event ID: {}",
----                                     event.id
----                                 );
-----                                ProcessedEvents::<T>::insert(event.id, true); // Mark the event as processed
----+                                ProcessedEvents::<T>::insert(event.id, true);
----+                                log::info!("Marked event {} as processed", event.id);
----                                 Self::remove_event_from_priority_queue(event.id).ok();
-----                                // Remove the event from the priority queue
----+                                log::info!("Removed event {} from priority queue", event.id);
----                             }
----                             Err(e) => {
----                                 log::error!("Error submitting unsigned transaction: {:?}", e);
----@@ -308,19 +309,12 @@ pub mod pallet {
----                         }
----                     } else {
----                         log::info!("Event {} is already processed", event.id);
-----                        Self::remove_event_from_priority_queue(event.id).ok(); // Ensure to remove already processed events
----+                        Self::remove_event_from_priority_queue(event.id).ok();
----                     }
----                 }
----             }
---- 
-----            // Process duplicates separately
-----            for event_group in duplicates.into_iter() {
-----                for event in event_group {
-----                    log::info!("Duplicate event detected: {:?}", event);
-----                    Self::remove_event_from_priority_queue(event.id).ok(); // Remove the duplicate event from the priority queue
-----                }
-----            }
-----
----+            log::info!("Finished processing all events");
----             Ok(())
----         }
----     }
----@@ -932,19 +926,19 @@ pub mod pallet {
----         #[pallet::call_index(2)]
----         #[pallet::weight(10_000)]
----         pub fn submit_encoded_payload(origin: OriginFor<T>, payload: Vec<u8>) -> DispatchResult {
-----            log::info!("submit_encoded_payload called with payload: {:?}", payload);
-----
----             let _who = ensure_none(origin)?;
-----
-----            // Decode the payload
-----            let call: Call<T> = Decode::decode(&mut &payload[..]).map_err(|e| {
-----                log::error!("Failed to decode payload: {:?}", e);
----+    
----+            // Decode the payload directly into a CustomEvent
----+            let event = CustomEvent::decode(&mut &payload[..]).map_err(|_| {
----+                // Instead of logging an error, we'll just return the InvalidPayload error
----                 Error::<T>::InvalidPayload
----             })?;
-----
-----            // Process the decoded call
-----            log::info!("Processing decoded call: {:?}", call);
-----            Self::process_decoded_call(call)
----+    
----+            // Store the event
----+            EventStorage::<T>::insert(event.id, event.clone());
----+    
----+            Self::deposit_event(Event::EventStored { event_id: event.id });
----+            Ok(())
----         }
----         #[pallet::call_index(3)]
----         #[pallet::weight(10_000)]
----@@ -991,6 +985,7 @@ pub mod pallet {
----         TransactionSubmissionError,
----         NoEventsInQueue,
----         JsonSerializationError,
----+      
----     }
---- 
----     #[pallet::event]
----@@ -999,6 +994,7 @@ pub mod pallet {
----         DataFetchedSuccessfully,
----         EventRemoved { event_id: u64 },
----         SomethingDone { param: u32 },
----+        EventStored { event_id: u64 },
----     }
---- 
----     #[pallet::type_value]
----diff --git a/pallets/pallet-registration/src/limits.rs b/pallets/pallet-registration/src/limits.rs
----index cbe2d98..29f2984 100644
------- a/pallets/pallet-registration/src/limits.rs
----+++ b/pallets/pallet-registration/src/limits.rs
----@@ -1,10 +1,9 @@
---- // limits.rs
-----use frame_support::pallet_prelude::Get;
-----use frame_support::pallet_prelude::MaxEncodedLen;
-----
---- use crate::types::CustomData;
---- use crate::types::CustomEvent;
-----use crate::types::EpochChangeData;
----+use crate::types::RegistrationData;
----+use frame_support::pallet_prelude::Get;
----+use frame_support::pallet_prelude::MaxEncodedLen;
---- 
---- pub struct MaxDataLength;
---- 
----@@ -20,7 +19,7 @@ impl MaxEncodedLen for CustomData {
----     }
---- }
---- 
-----impl MaxEncodedLen for EpochChangeData {
----+impl MaxEncodedLen for RegistrationData {
----     fn max_encoded_len() -> usize {
----         u32::MAX as usize
----     }
----@@ -33,7 +32,6 @@ impl Get<u32> for MaxDataLength {
---- }
---- 
---- pub struct MaxPayloadLength;
-----
---- impl Get<u32> for MaxPayloadLength {
----     fn get() -> u32 {
----         1024 // Define your max length here
----@@ -41,7 +39,6 @@ impl Get<u32> for MaxPayloadLength {
---- }
---- 
---- pub struct MaxEventsLength;
-----
---- impl Get<u32> for MaxEventsLength {
----     fn get() -> u32 {
----         100 // Define your max length here
----@@ -49,7 +46,6 @@ impl Get<u32> for MaxEventsLength {
---- }
---- 
---- pub struct MaxRemoveEventsLength;
-----
---- impl Get<u32> for MaxRemoveEventsLength {
----     fn get() -> u32 {
----         100 // Define your max length here
----diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
----index caef2a2..58d0dbe 100644
------- a/pallets/pallet-registration/src/mock.rs
----+++ b/pallets/pallet-registration/src/mock.rs
----@@ -1,33 +1,50 @@
---- #![cfg_attr(not(feature = "std"), no_std)]
---- 
----+use crate as pallet_registration;
----+use crate::RegistrationData;
---- use crate::{CustomData, CustomEvent};
----+use crate::{Error, Event};
---- use frame_support::{
----     construct_runtime, parameter_types,
----     traits::{ConstU32, ConstU64, Everything, PalletInfo as FramePalletInfo},
---- };
-----use frame_system::offchain::SendTransactionTypes;
-----use crate as pallet_registration;
---- use frame_system as system;
----+use frame_system::offchain::SendTransactionTypes;
---- use scale_info::TypeInfo;
---- use serde::{Deserialize, Serialize};
---- use sp_application_crypto::{ed25519, RuntimePublic};
---- use sp_consensus_aura::sr25519::AuthorityId as AuraId;
-----use sp_core::{H256, offchain::KeyTypeId, Pair};
----+use sp_core::{offchain::KeyTypeId, Pair, H256};
----+use sp_runtime::impl_opaque_keys;
----+use sp_runtime::testing::UintAuthorityId;
---- use sp_runtime::{
----     app_crypto::{sr25519, RuntimeAppPublic},
----     codec::{Decode, Encode, MaxEncodedLen},
----     generic::{Era, SignedPayload},
-----    traits::{BlakeTwo256, IdentifyAccount, IdentityLookup, OpaqueKeys, SaturatedConversion, Verify},
-----    AccountId32, MultiSignature, BuildStorage,
----+    traits::{
----+        BlakeTwo256, IdentifyAccount, IdentityLookup, OpaqueKeys, SaturatedConversion, Verify,
----+    },
----+    AccountId32, BuildStorage, MultiSignature,
---- };
-----use sp_runtime::impl_opaque_keys;
---- use sp_std::collections::btree_map::BTreeMap;
---- use substrate_validator_set;
-----use sp_runtime::testing::UintAuthorityId;
---- 
---- type Block = frame_system::mocking::MockBlock<Test>;
---- 
-----#[derive(Clone, PartialEq, Eq, Debug, Encode, Decode, MaxEncodedLen, TypeInfo, Serialize, Deserialize, Ord, PartialOrd)]
----+#[derive(
----+    Clone,
----+    PartialEq,
----+    Eq,
----+    Debug,
----+    Encode,
----+    Decode,
----+    MaxEncodedLen,
----+    TypeInfo,
----+    Serialize,
----+    Deserialize,
----+    Ord,
----+    PartialOrd,
----+)]
---- pub struct MyAccountId(u64);
---- 
---- impl std::fmt::Display for MyAccountId {
----@@ -42,7 +59,6 @@ impl From<u64> for MyAccountId {
----     }
---- }
---- 
-----
---- impl From<MyAccountId> for sp_runtime::AccountId32 {
----     fn from(account: MyAccountId) -> Self {
----         let mut bytes = [0u8; 32];
----@@ -73,7 +89,6 @@ impl From<sr25519::Public> for TestAccountPublic {
----     }
---- }
---- 
-----
---- pub struct MockAccountId32Convert;
---- 
---- impl MockAccountId32Convert {
----@@ -133,7 +148,7 @@ impl frame_system::Config for Test {
---- }
---- 
---- parameter_types! {
-----   
----+
----     pub static Validators: Vec<u64> = vec![1, 2, 3];
----     pub static NextValidators: Vec<u64> = vec![1, 2, 3];
----     pub static Authorities: Vec<UintAuthorityId> = vec![UintAuthorityId(1), UintAuthorityId(2), UintAuthorityId(3)];
----@@ -210,10 +225,6 @@ construct_runtime!(
----     }
---- );
---- 
-----
-----
-----
-----
---- impl pallet_registration::Config for Test {
----     type RuntimeEvent = RuntimeEvent;
----     type WeightInfo = ();
----@@ -284,7 +295,6 @@ where
---- )]
---- pub struct TestAccountPublic(sr25519::Public);
---- 
-----
---- impl Default for TestAccountPublic {
----     fn default() -> Self {
----         TestAccountPublic(sr25519::Public::from_raw([0u8; 32]))
----@@ -322,8 +332,6 @@ impl frame_system::offchain::SigningTypes for Test {
----     type Signature = sr25519::Signature;
---- }
---- 
-----
-----
---- impl From<MyAccountId> for u64 {
----     fn from(account: MyAccountId) -> Self {
----         account.0
----@@ -348,13 +356,142 @@ pub fn new_test_ext() -> sp_io::TestExternalities {
---- #[cfg(test)]
---- mod tests {
----     use super::*;
-----    use frame_support::assert_ok;
-----    use sp_io::TestExternalities;
----+    use frame_support::{assert_noop, assert_ok};
----+    use sp_runtime::testing::TestSignature;
----+
----+    fn create_test_event() -> CustomEvent {
----+        CustomEvent {
----+            id: 1,
----+            data: CustomData {
----+                event_type: "RegistrationEvent".into(),
----+                data: RegistrationData {
----+                    user_id: "user123".into(),
----+                    username: "testuser".into(),
----+                    email: "test@example.com".into(),
----+                },
----+            },
----+            timestamp: 1000,
----+            block_height: 100,
----+        }
----+    }
----+
----+    #[test]
----+    fn test_submit_encoded_payload() {
----+        new_test_ext().execute_with(|| {
----+            let event = create_test_event();
----+            let payload = event.encode();
----+
----+            assert_ok!(Registration::submit_encoded_payload(
----+                RuntimeOrigin::none(),
----+                payload.clone()
----+            ));
----+
----+            // Check if the event is stored
----+            assert_eq!(Registration::event_storage(event.id), event);
----+        });
----+    }
----+    #[test]
----+    fn test_submit_multiple_events() {
----+        new_test_ext().execute_with(|| {
----+            let event1 = create_test_event();
----+            let event2 = CustomEvent {
----+                id: 2,
----+                ..create_test_event()
----+            };
----+
----+            assert_ok!(Registration::submit_encoded_payload(
----+                RuntimeOrigin::none(),
----+                event1.encode()
----+            ));
----+            assert_ok!(Registration::submit_encoded_payload(
----+                RuntimeOrigin::none(),
----+                event2.encode()
----+            ));
----+
----+            assert_eq!(Registration::event_storage(event1.id), event1);
----+            assert_eq!(Registration::event_storage(event2.id), event2);
----+        });
----+    }
----+    #[test]
----+    fn test_submit_invalid_payload() {
----+        new_test_ext().execute_with(|| {
----+            let invalid_payload = vec![0, 1, 2, 3]; // This is not a valid encoded CustomEvent
----+            assert_noop!(
----+                Registration::submit_encoded_payload(RuntimeOrigin::none(), invalid_payload),
----+                Error::<Test>::InvalidPayload
----+            );
----+        });
----+    }
----+
----+    // #[test]
----+    // fn test_manual_fetch() {
----+    //     new_test_ext().execute_with(|| {
----+    //         let account = MyAccountId(1);
----+    //         assert_ok!(Registration::manual_fetch(RuntimeOrigin::signed(account)));
----+    //         // You might want to add more assertions here based on the expected behavior
----+    //     });
----+    // }
----+
----+    #[test]
----+    fn test_remove_event_from_storage() {
----+        new_test_ext().execute_with(|| {
----+            let event = create_test_event();
----+            let payload = event.encode();
----+
----+            assert_ok!(Registration::submit_encoded_payload(
----+                RuntimeOrigin::none(),
----+                payload.clone()
----+            ));
----+
----+            let account = MyAccountId(1);
----+            assert_ok!(Registration::remove_event_from_storage(
----+                RuntimeOrigin::signed(account),
----+                event.id
----+            ));
----+
----+            // Check if the event is removed
----+            assert_eq!(
----+                Registration::event_storage(event.id),
----+                CustomEvent::default()
----+            );
----+        });
----+    }
----+
----+    #[test]
----+    fn test_process_registration_event() {
----+        new_test_ext().execute_with(|| {
----+            let event = create_test_event();
----+            let payload = event.encode();
----+            let nonce = 1u64;
----+
----+            assert_ok!(Registration::process_registration_event(
----+                RuntimeOrigin::signed(MyAccountId(1)),
----+                nonce,
----+                payload
----+            ));
----+        });
----+    }
----+
----+    #[test]
----+    fn test_store_event_id() {
----+        new_test_ext().execute_with(|| {
----+            let event_id = "test_event_id".to_string();
----+            assert_ok!(Registration::store_event_id(
----+                RuntimeOrigin::none(),
----+                event_id
----+            ));
----+        });
----+    }
---- 
----     #[test]
-----    fn test_genesis_config_builds() {
----+    fn test_do_something() {
----         new_test_ext().execute_with(|| {
-----            assert_eq!(System::block_number(), 1);
----+            let account = MyAccountId(1);
----+            let param = 42u32;
----+            assert_ok!(Registration::do_something(
----+                RuntimeOrigin::signed(account),
----+                param
----+            ));
----         });
----     }
---- }
----diff --git a/pallets/pallet-registration/src/types.rs b/pallets/pallet-registration/src/types.rs
----index 344dd7c..7cac594 100644
------- a/pallets/pallet-registration/src/types.rs
----+++ b/pallets/pallet-registration/src/types.rs
----@@ -42,7 +42,7 @@ impl CustomEvent {
---- pub struct CustomData {
----     #[serde(rename = "type")]
----     pub event_type: String,
-----    pub data: EpochChangeData,
----+    pub data: RegistrationData,
---- }
---- 
---- impl CustomData {
----@@ -56,29 +56,17 @@ impl CustomData {
---- #[derive(
----     Default, Deserialize, Serialize, Encode, Decode, Clone, Debug, PartialEq, Eq, TypeInfo,
---- )]
-----pub struct EpochChangeData {
-----    pub last_epoch: u64,
-----    pub last_blockhash: String,
-----    pub last_slot: u64,
-----    pub new_epoch: u64,
-----    pub new_slot: u64,
-----    pub new_blockhash: String,
-----    pub epoch_nonce: String,
-----    pub extra_entropy: Option<String>,
----+pub struct RegistrationData {
----+    pub user_id: String,
----+    pub username: String,
----+    pub email: String,
---- }
---- 
-----impl EpochChangeData {
----+impl RegistrationData {
----     pub fn hash(&self) -> [u8; 32] {
-----        let mut encoded_data = self.last_epoch.encode();
-----        encoded_data.extend(self.last_blockhash.encode());
-----        encoded_data.extend(self.last_slot.encode());
-----        encoded_data.extend(self.new_epoch.encode());
-----        encoded_data.extend(self.new_slot.encode());
-----        encoded_data.extend(self.new_blockhash.encode());
-----        encoded_data.extend(self.epoch_nonce.encode());
-----        if let Some(extra_entropy) = &self.extra_entropy {
-----            encoded_data.extend(extra_entropy.encode());
-----        }
----+        let mut encoded_data = self.user_id.encode();
----+        encoded_data.extend(self.username.encode());
----+        encoded_data.extend(self.email.encode());
----         blake2_256(&encoded_data)
----     }
---- }
----diff --git a/pallets/substrate-validator-set/src/lib.rs b/pallets/substrate-validator-set/src/lib.rs
----index 88bbb9c..95e5899 100644
------- a/pallets/substrate-validator-set/src/lib.rs
----+++ b/pallets/substrate-validator-set/src/lib.rs
----@@ -183,7 +183,6 @@ pub mod pallet {
---- }
---- 
---- impl<T: Config> Pallet<T> {
-----	
---- 	fn verify_nft_mint_event(
---- 		nft_policy_id: &[u8],
---- 		nft_asset_name: &[u8],
----@@ -194,12 +193,12 @@ impl<T: Config> Pallet<T> {
---- 		// Implement your verification logic here
---- 		true // Placeholder implementation
---- 	}
-----	
----+
---- 	fn is_eligible_validator(account: &T::AccountId) -> bool {
---- 		// Implement your eligibility check logic here
---- 		true // Placeholder implementation
---- 	}
-----	
----+
---- 	fn do_add_validator(
---- 		validator_id: <T as pallet_session::Config>::ValidatorId,
---- 	) -> DispatchResult {
----diff --git a/runtime/src/lib.rs b/runtime/src/lib.rs
----index fc5ae1e..712a368 100644
------- a/runtime/src/lib.rs
----+++ b/runtime/src/lib.rs
----@@ -383,11 +383,11 @@ impl pallet_epoch::Config for Runtime {
---- // impl pallet_registration::Config for Runtime {
---- //     type RuntimeEvent = RuntimeEvent;
---- //     type WeightInfo = ();
-----    // type AuthorityId = AuraId;
-----    // type ValidatorId = MVa  AccountId;
-----    // type AccountId32Convert = MockAccountId32Convert;
-----    // type Call = RuntimeCall;
-----    // type UnsignedPriority = frame_support::traits::ConstU64<100>;
----+// type AuthorityId = AuraId;
----+// type ValidatorId = MVa  AccountId;
----+// type AccountId32Convert = MockAccountId32Convert;
----+// type Call = RuntimeCall;
----+// type UnsignedPriority = frame_support::traits::ConstU64<100>;
---- // }
---- 
---- parameter_types! {
---diff --git a/pallets/chain-listener/src/tests.rs b/pallets/chain-listener/src/tests.rs
---index 6c49191..2eaf327 100644
------ a/pallets/chain-listener/src/tests.rs
---+++ b/pallets/chain-listener/src/tests.rs
---@@ -1,5 +1,8 @@
--- use crate::{mock::*, Error, Event, Something};
--- use frame_support::{assert_noop, assert_ok};
---+use sp_io::TestExternalities;
---+
---+use sp_core::offchain::{testing, OffchainWorkerExt, TransactionPoolExt};
--- 
--- #[test]
--- fn it_works_for_default_value() {
---@@ -39,7 +42,7 @@ fn correct_error_for_none_value() {
--- //         testing::{self, OffchainState, OffchainWorkerExt, TestOffchainExt},
--- //         OffchainDbExt,
--- //     };
----//     use sp_io::TestExternalities;
---+//     
--- 
--- //     fn setup_ext() -> TestExternalities {
--- //         let (offchain, _) = testing::TestOffchainExt::new();
---diff --git a/pallets/pallet-registration/Cargo.toml b/pallets/pallet-registration/Cargo.toml
---index f81b6c9..c674292 100644
------ a/pallets/pallet-registration/Cargo.toml
---+++ b/pallets/pallet-registration/Cargo.toml
---@@ -30,10 +30,12 @@ substrate-validator-set = { workspace = true, default-features = false, features
--- pallet-im-online = { workspace = true, default-features = false, features = ['std'] }
--- sp-consensus-grandpa = { workspace = true, default-features = false, features = ['std'] }
--- hex-literal = { workspace = true, default-features = false }    
---+sp-keystore = { workspace = true, default-features = false, features = ['std'] }
--- [dev-dependencies]
---+sp-core = { workspace = true, default-features = false, features = ['std'] }
--- sp-consensus-aura = { git = "https://github.com/paritytech/polkadot-sdk", branch = "release-polkadot-v1.9.0", default-features = false }
--- mockall = "0.12.1" 
----
---+sp-keystore = { workspace = true, default-features = false, features = ['std'] }
--- [features]
--- default = ["std"]
--- std = [
---diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
---index 950eecc..52c3463 100644
------ a/pallets/pallet-registration/src/lib.rs
---+++ b/pallets/pallet-registration/src/lib.rs
---@@ -19,7 +19,9 @@ use pallet_im_online::sr25519::AuthorityId as ImOnlineId;
--- use serde::{Deserialize, Deserializer, Serialize, Serializer};
--- use sp_application_crypto::ed25519::Signature;
--- use sp_consensus_grandpa::AuthorityId as GrandpaId;
---+use sp_core::offchain::{testing, OffchainWorkerExt, TransactionPoolExt};
--- use sp_core::sr25519::Public as Sr25519Public;
---+use sp_io::TestExternalities;
--- use sp_runtime::traits::IdentifyAccount;
--- 
--- use scale_info::TypeInfo;
---@@ -216,12 +218,22 @@ pub mod pallet {
---         ) -> <T as pallet::Config>::ValidatorId {
---             key.into()
---         }
---+        // Helper function to insert a pending event
---+        pub fn insert_pending_event(event_id: u64) -> Result<(), Error<T>> {
---+            PendingEvents::<T>::insert(event_id, ());
---+            Ok(())
---+        }
---+
---+        // Helper function to check if an event is pending
---+        pub fn is_event_pending(event_id: u64) -> bool {
---+            PendingEvents::<T>::contains_key(event_id)
---+        }
---     }
---     impl<T: Config> Pallet<T>
---     where
---         T: frame_system::offchain::SendTransactionTypes<Call<T>>,
---     {
----        fn fetch_event_id(event_id: u64) -> Result<String, Error<T>> {
---+        pub fn fetch_event_id(event_id: u64) -> Result<String, Error<T>> {
---             let url = "http://127.0.0.1:5555";
---             let request_body = serde_json::json!({
---                 "jsonrpc": "2.0",
---@@ -265,7 +277,7 @@ pub mod pallet {
--- 
---             Err(<Error<T>>::InvalidResponseFormat)
---         }
----        fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
---+        pub fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
---             log::info!("Starting to fetch and process events");
--- 
---             let response = Self::process_real_event()?;
---@@ -385,7 +397,7 @@ pub mod pallet {
---         <T as pallet_session::Config>::ValidatorId: Clone,
---         T::AuthorityId: AppCrypto + From<sp_core::sr25519::Public>,
---     {
----        fn sign_payload(payload: &[u8]) -> Result<Sr25519Signature, &'static str> {
---+        pub fn sign_payload(payload: &[u8]) -> Result<Sr25519Signature, &'static str> {
---             log::info!("Attempting to sign payload: {:?}", payload);
--- 
---             let local_keys = Self::fetch_local_keys();
---@@ -823,7 +835,7 @@ pub mod pallet {
---             Some(EventStorage::<T>::get(event_id))
---         }
---         // Use structured logging for better clarity in logs.
----        fn log_event_processing(event: &CustomEvent) {
---+        pub fn log_event_processing(event: &CustomEvent) {
---             log::info!(
---                 target: "event_processing",
---                 "Processing event: id={}, timestamp={}, block_height={}",
---@@ -927,16 +939,20 @@ pub mod pallet {
---         #[pallet::weight(10_000)]
---         pub fn submit_encoded_payload(origin: OriginFor<T>, payload: Vec<u8>) -> DispatchResult {
---             let _who = ensure_none(origin)?;
----    
---+
---             // Decode the payload directly into a CustomEvent
----            let event = CustomEvent::decode(&mut &payload[..]).map_err(|_| {
----                // Instead of logging an error, we'll just return the InvalidPayload error
----                Error::<T>::InvalidPayload
----            })?;
----    
---+            let event =
---+                CustomEvent::decode(&mut &payload[..]).map_err(|_| Error::<T>::InvalidPayload)?;
---+
---+            // Check if the event is already processed or stored
---+            ensure!(!Self::is_duplicate(&event), Error::<T>::DuplicateEvent);
---+
---             // Store the event
---             EventStorage::<T>::insert(event.id, event.clone());
----    
---+
---+            // Mark the event as processed
---+            ProcessedEvents::<T>::insert(event.id, true);
---+
---             Self::deposit_event(Event::EventStored { event_id: event.id });
---             Ok(())
---         }
---@@ -985,7 +1001,7 @@ pub mod pallet {
---         TransactionSubmissionError,
---         NoEventsInQueue,
---         JsonSerializationError,
----      
---+        DuplicateEvent,
---     }
--- 
---     #[pallet::event]
---diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
---index 58d0dbe..3205930 100644
------ a/pallets/pallet-registration/src/mock.rs
---+++ b/pallets/pallet-registration/src/mock.rs
---@@ -4,6 +4,7 @@ use crate as pallet_registration;
--- use crate::RegistrationData;
--- use crate::{CustomData, CustomEvent};
--- use crate::{Error, Event};
---+use frame_support::storage::StorageMap;
--- use frame_support::{
---     construct_runtime, parameter_types,
---     traits::{ConstU32, ConstU64, Everything, PalletInfo as FramePalletInfo},
---@@ -29,6 +30,9 @@ use sp_runtime::{
--- use sp_std::collections::btree_map::BTreeMap;
--- use substrate_validator_set;
--- 
---+use sp_core::offchain::{testing, OffchainWorkerExt};
---+use sp_io::TestExternalities;
---+
--- type Block = frame_system::mocking::MockBlock<Test>;
--- 
--- #[derive(
---@@ -356,6 +360,8 @@ pub fn new_test_ext() -> sp_io::TestExternalities {
--- #[cfg(test)]
--- mod tests {
---     use super::*;
---+    // use crate::mock::{new_test_ext, Test};
---+    use crate::mock::{new_test_ext, Registration, Test};
---     use frame_support::{assert_noop, assert_ok};
---     use sp_runtime::testing::TestSignature;
--- 
---@@ -375,21 +381,6 @@ mod tests {
---         }
---     }
--- 
----    #[test]
----    fn test_submit_encoded_payload() {
----        new_test_ext().execute_with(|| {
----            let event = create_test_event();
----            let payload = event.encode();
----
----            assert_ok!(Registration::submit_encoded_payload(
----                RuntimeOrigin::none(),
----                payload.clone()
----            ));
----
----            // Check if the event is stored
----            assert_eq!(Registration::event_storage(event.id), event);
----        });
----    }
---     #[test]
---     fn test_submit_multiple_events() {
---         new_test_ext().execute_with(|| {
---@@ -412,6 +403,7 @@ mod tests {
---             assert_eq!(Registration::event_storage(event2.id), event2);
---         });
---     }
---+
---     #[test]
---     fn test_submit_invalid_payload() {
---         new_test_ext().execute_with(|| {
---@@ -423,17 +415,16 @@ mod tests {
---         });
---     }
--- 
----    // #[test]
----    // fn test_manual_fetch() {
----    //     new_test_ext().execute_with(|| {
----    //         let account = MyAccountId(1);
----    //         assert_ok!(Registration::manual_fetch(RuntimeOrigin::signed(account)));
----    //         // You might want to add more assertions here based on the expected behavior
----    //     });
----    // }
---+    #[test]
---+    fn test_manual_fetch() {
---+        new_test_ext().execute_with(|| {
---+            let account = MyAccountId(1);
---+            assert_ok!(Registration::manual_fetch(RuntimeOrigin::signed(account)));
---+        });
---+    }
--- 
---     #[test]
----    fn test_remove_event_from_storage() {
---+    fn test_remove_event_from_storage2() {
---         new_test_ext().execute_with(|| {
---             let event = create_test_event();
---             let payload = event.encode();
---@@ -471,27 +462,320 @@ mod tests {
---             ));
---         });
---     }
---+    #[test]
---+    fn test_fetch_and_process_events_from_queue() {
---+        let (offchain, state) = testing::TestOffchainExt::new();
---+        let mut t = TestExternalities::default();
---+        t.register_extension(OffchainWorkerExt::new(offchain));
---+
---+        t.execute_with(|| {
---+            // Mock the HTTP request
---+            state.write().expect_request(testing::PendingRequest {
---+                method: "POST".into(),
---+                uri: "http://127.0.0.1:5555".into(),
---+                headers: vec![
---+                    ("User-Agent".into(), "SubstrateOffchainWorker".into()),
---+                    ("Content-Type".into(), "application/json".into()),
---+                ],
---+                body: br#"{"id":1,"jsonrpc":"2.0","method":"list_all_events","params":[]}"#
---+                    .to_vec(),
---+                response: Some(
---+                    br#"{"result":"{\"events\":[],\"duplicates\":[],\"success\":true}"}"#.to_vec(),
---+                ),
---+                sent: true,
---+                ..Default::default()
---+            });
---+
---+            // This test checks if the function doesn't panic
---+            assert_ok!(Registration::fetch_and_process_events_from_queue());
---+        });
---+    }
---+    #[test]
---+    fn test_fetch_event_id() {
---+        let (offchain, state) = testing::TestOffchainExt::new();
---+        let mut t = TestExternalities::default();
---+        t.register_extension(OffchainWorkerExt::new(offchain));
---+
---+        t.execute_with(|| {
---+            let event_id = 1;
---+
---+            // Mock the HTTP request
---+            state.write().expect_request(testing::PendingRequest {
---+                method: "POST".into(),
---+                uri: "http://127.0.0.1:5555".into(),
---+                headers: vec![
---+                    ("Content-Type".into(), "application/json".into()),
---+                    ("User-Agent".into(), "SubstrateOffchainWorker".into()),
---+                ],
---+                body: br#"{"id":1,"jsonrpc":"2.0","method":"get_event_id","params":[1]}"#.to_vec(),
---+                response: Some(br#"{"success":true,"event_id":"mocked_event_id"}"#.to_vec()),
---+                sent: true,
---+                ..Default::default()
---+            });
---+
---+            let result = Registration::fetch_event_id(event_id);
---+            assert!(result.is_ok(), "fetch_event_id should succeed");
---+            assert_eq!(result.unwrap(), "mocked_event_id".to_string());
---+        });
---+    }
--- 
---     #[test]
----    fn test_store_event_id() {
---+    fn test_event_duplication() {
---         new_test_ext().execute_with(|| {
----            let event_id = "test_event_id".to_string();
----            assert_ok!(Registration::store_event_id(
---+            let event = create_test_event();
---+            let payload = event.encode();
---+
---+            // First submission should succeed
---+            assert_ok!(Registration::submit_encoded_payload(
---                 RuntimeOrigin::none(),
----                event_id
---+                payload.clone()
---             ));
---+
---+            // Second submission of the same event should fail due to duplication
---+            assert_noop!(
---+                Registration::submit_encoded_payload(RuntimeOrigin::none(), payload.clone()),
---+                Error::<Test>::DuplicateEvent
---+            );
---+
---+            // Verify that the event is stored
---+            assert_eq!(Registration::event_storage(event.id), event);
---         });
---     }
--- 
---     #[test]
----    fn test_do_something() {
---+    fn test_event_storage() {
---         new_test_ext().execute_with(|| {
----            let account = MyAccountId(1);
----            let param = 42u32;
----            assert_ok!(Registration::do_something(
----                RuntimeOrigin::signed(account),
----                param
---+            let event = CustomEvent {
---+                id: 1,
---+                data: CustomData {
---+                    event_type: "Test".into(),
---+                    data: RegistrationData {
---+                        user_id: "user1".into(),
---+                        username: "testuser".into(),
---+                        email: "test@example.com".into(),
---+                    },
---+                },
---+                timestamp: 1000,
---+                block_height: 10,
---+            };
---+
---+            // Use the public interface to store the event
---+            assert_ok!(Registration::submit_encoded_payload(
---+                RuntimeOrigin::none(),
---+                event.encode()
---             ));
---+
---+            // Check if the event is stored correctly
---+            assert_eq!(Registration::event_storage(event.id), event);
---         });
---     }
---+    #[test]
---+    fn test_log_event_processing() {
---+        new_test_ext().execute_with(|| {
---+            let event = CustomEvent {
---+                id: 1,
---+                data: CustomData {
---+                    event_type: "Test".into(),
---+                    data: RegistrationData {
---+                        user_id: "user1".into(),
---+                        username: "testuser".into(),
---+                        email: "test@example.com".into(),
---+                    },
---+                },
---+                timestamp: 1000,
---+                block_height: 10,
---+            };
---+
---+            // This test just ensures the function doesn't panic
---+            Registration::log_event_processing(&event);
---+
---+            // Since we can't easily check the log output in a test,
---+            // we'll just assert that the function completed successfully
---+            assert!(true);
---+        });
---+    }
---+
---+    //     // This test just ensures the function doesn't panic
---+    //     Pallet::<Test>::log_event_processing(&event);
---+    // }
---+
---+    // #[test]
---+    // fn test_is_leader() {
---+    //     new_test_ext().execute_with(|| {
---+    //         // This test might require more setup to properly test leadership
---+    //         // For now, we'll just ensure the function runs without panicking
---+    //         let _ = Pallet::<Test>::is_leader();
---+    //     });
---+    // }
---+
---+    #[test]
---+    fn test_pending_events() {
---+        new_test_ext().execute_with(|| {
---+            // Insert a pending event
---+            crate::PendingEvents::<Test>::insert(1, ());
---+
---+            // Check if the pending event exists
---+            assert!(crate::PendingEvents::<Test>::contains_key(1));
---+
---+            // Optional: Check that a non-existent key returns false
---+            assert!(!crate::PendingEvents::<Test>::contains_key(2));
---+        });
---+    }
---+
---+    // #[test]
---+    // fn test_process_real_event() {
---+    //     new_test_ext().execute_with(|| {
---+    //         // This test might be challenging to implement without mocking HTTP requests
---+    //         // For now, we'll just check if the function doesn't panic
---+    //         let _ = Pallet::<Test>::process_real_event();
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_process_response() {
---+    //     let data = r#"[{"asset_id":"BTC","quantity":100}]"#.as_bytes().to_vec();
---+    //     assert_ok!(Pallet::<Test>::process_response(data));
---+    // }
---+
---+    // #[test]
---+    // fn test_processed_events() {
---+    //     new_test_ext().execute_with(|| {
---+    //         ProcessedEvents::<Test>::insert(1, true);
---+    //         assert!(ProcessedEvents::<Test>::contains_key(1));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_processed_events() {
---+    //     new_test_ext().execute_with(|| {
---+    //         <pallet_registration::Pallet<Test>>::ProcessedEvents::insert(1, true);
---+    //         assert!(<pallet_registration::Pallet<Test>>::ProcessedEvents::contains_key(1));
---+    //     });
---+    // }
---+    
---+
---+
---+    // #[test]
---+    // fn test_remove_event_from_storage() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let event = CustomEvent {
---+    //             id: 1,
---+    //             data: CustomData {
---+    //                 event_type: "Test".into(),
---+    //                 data: RegistrationData {
---+    //                     user_id: "user1".into(),
---+    //                     username: "testuser".into(),
---+    //                     email: "test@example.com".into(),
---+    //                 },
---+    //             },
---+    //             timestamp: 1000,
---+    //             block_height: 10,
---+    //         };
---+
---+    //         EventStorage::<Test>::insert(event.id, event);
---+
---+    //         assert_ok!(Pallet::<Test>::remove_event_from_storage(Origin::signed(MyAccountId(1)), 1));
---+    //         assert!(!EventStorage::<Test>::contains_key(1));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_processed_transactions() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let payload = vec![0, 1, 2, 3];
---+    //         ProcessedTransactions::<Test>::insert(payload.clone(), true);
---+    //         assert!(ProcessedTransactions::<Test>::contains_key(payload));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_store_event_in_mempool() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let event = CustomEvent {
---+    //             id: 1,
---+    //             data: CustomData {
---+    //                 event_type: "Test".into(),
---+    //                 data: RegistrationData {
---+    //                     user_id: "user1".into(),
---+    //                     username: "testuser".into(),
---+    //                     email: "test@example.com".into(),
---+    //                 },
---+    //             },
---+    //             timestamp: 1000,
---+    //             block_height: 10,
---+    //         };
---+
---+    //         assert_ok!(Pallet::<Test>::store_event_in_mempool(event.clone()));
---+    //         assert_eq!(EventStorage::<Test>::get(event.id), event);
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_submit_encoded_payload() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let event = CustomEvent {
---+    //             id: 1,
---+    //             data: CustomData {
---+    //                 event_type: "Test".into(),
---+    //                 data: RegistrationData {
---+    //                     user_id: "user1".into(),
---+    //                     username: "testuser".into(),
---+    //                     email: "test@example.com".into(),
---+    //                 },
---+    //             },
---+    //             timestamp: 1000,
---+    //             block_height: 10,
---+    //         };
---+    //         let payload = event.encode();
---+    //         assert_ok!(Pallet::<Test>::submit_encoded_payload(Origin::none(), payload));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_submit_unsigned_transaction() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let event = CustomEvent {
---+    //             id: 1,
---+    //             data: CustomData {
---+    //                 event_type: "Test".into(),
---+    //                 data: RegistrationData {
---+    //                     user_id: "user1".into(),
---+    //                     username: "testuser".into(),
---+    //                     email: "test@example.com".into(),
---+    //                 },
---+    //             },
---+    //             timestamp: 1000,
---+    //             block_height: 10,
---+    //         };
---+    //         let payload = event.encode();
---+    //         assert_ok!(Pallet::<Test>::submit_unsigned_transaction(payload, 1));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_validate_and_process_event() {
---+    //     new_test_ext().execute_with(|| {
---+    //         let event = CustomEvent {
---+    //             id: 1,
---+    //             data: CustomData {
---+    //                 event_type: "Test".into(),
---+    //                 data: RegistrationData {
---+    //                     user_id: "user1".into(),
---+    //                     username: "testuser".into(),
---+    //                     email: "test@example.com".into(),
---+    //                 },
---+    //             },
---+    //             timestamp: 1000,
---+    //             block_height: 10,
---+    //         };
---+    //         assert_ok!(Pallet::<Test>::validate_and_process_event(event));
---+    //     });
---+    // }
---+
---+    // #[test]
---+    // fn test_store_event_id() {
---+    //     new_test_ext().execute_with(|| {
---+    //         assert_ok!(Pallet::<Test>::store_event_id(Origin::none(), "event1".into()));
---+    //     });
---+    // }
--- }
--diff --git a/pallets/chain-listener/src/lib.rs b/pallets/chain-listener/src/lib.rs
--index 845e39c..4ed86d5 100644
----- a/pallets/chain-listener/src/lib.rs
--+++ b/pallets/chain-listener/src/lib.rs
--@@ -89,6 +89,7 @@ pub mod pallet {
--         type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
--         type WeightInfo: WeightInfo;
--         type AuthorityId: Public;
--+        
--         // type SubmitTransaction: frame_system::offchain::SendSignedTransaction<Self, AppCrypto, Call<Self>>;
-- 
--         // Authority identifier for signing transactions
--diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
--index 52c3463..d95048c 100644
----- a/pallets/pallet-registration/src/lib.rs
--+++ b/pallets/pallet-registration/src/lib.rs
--@@ -120,6 +120,7 @@ pub mod pallet {
--         type AccountId32Convert: From<AccountId32> + Into<Self::AccountId>;
--         type Call: From<Call<Self>>;
--         type UnsignedPriority: Get<u64>;
--+        type AdminAccount: Get<Self::AccountId>;
--     }
-- 
--     #[pallet::pallet]
--@@ -334,7 +335,7 @@ pub mod pallet {
--     use alloc::format;
-- 
--     impl<T: Config> Pallet<T> {
---        fn submit_unsigned_transaction(
--+        pub fn submit_unsigned_transaction(
--             payload: Vec<u8>,
--             event_id: u64,
--         ) -> Result<(), &'static str> {
--@@ -743,7 +744,7 @@ pub mod pallet {
--             false
--         }
--         // Step 4: Message Validation
---        fn validate_and_process_event(event: CustomEvent) -> Result<(), Error<T>> {
--+        pub fn validate_and_process_event(event: CustomEvent) -> Result<(), Error<T>> {
--             // Validate the event data
--             if event.timestamp == 0 || event.block_height == 0 {
--                 return Err(Error::<T>::InvalidEventData);
--@@ -770,7 +771,7 @@ pub mod pallet {
--         }
-- 
--         // Step 2: Message Storage
---        fn store_event_in_mempool(event: CustomEvent) -> Result<(), &'static str> {
--+        pub fn store_event_in_mempool(event: CustomEvent) -> Result<(), &'static str> {
--             EventStorage::<T>::insert(event.id, event);
--             Ok(())
--         }
--@@ -842,6 +843,26 @@ pub mod pallet {
--                 event.id, event.timestamp, event.block_height
--             );
--         }
--+        pub fn update_event(
--+            origin: T::RuntimeOrigin,
--+            event_id: u64,
--+            new_event: CustomEvent,
--+        ) -> DispatchResult {
--+            let who = ensure_signed(origin)?;
--+
--+            // Ensure the event exists
--+            ensure!(
--+                EventStorage::<T>::contains_key(event_id),
--+                Error::<T>::EventNotFound
--+            );
--+
--+            // Update the event in storage
--+            EventStorage::<T>::insert(event_id, new_event);
--+
--+            Self::deposit_event(Event::EventUpdated { who, event_id });
--+
--+            Ok(())
--+        }
--     }
-- 
--     // Add more descriptive error messages to help with debugging.
--@@ -866,7 +887,7 @@ pub mod pallet {
--     }
-- 
--     impl<T: Config> Pallet<T> {
---        fn process_response(data: Vec<u8>) -> Result<(), &'static str> {
--+        pub fn process_response(data: Vec<u8>) -> Result<(), &'static str> {
--             if let Ok(assets) = serde_json::from_slice::<Vec<Asset>>(&data) {
--                 // Process each asset
--                 for asset in assets {
--@@ -958,15 +979,21 @@ pub mod pallet {
--         }
--         #[pallet::call_index(3)]
--         #[pallet::weight(10_000)]
---        pub fn remove_event_from_storage(origin: OriginFor<T>, event_id: u64) -> DispatchResult {
---            let _who = ensure_signed(origin)?;
---            ensure!(
---                EventStorage::<T>::contains_key(event_id),
---                Error::<T>::EventNotFound
---            );
---
---            EventStorage::<T>::remove(event_id);
---
--+        pub fn remove_event_from_storage(
--+            origin: T::RuntimeOrigin,
--+            event_id: u64,
--+        ) -> DispatchResult {
--+            let who = ensure_signed(origin)?;
--+        
--+            // Ensure the caller is an admin
--+            ensure!(who == T::AdminAccount::get(), Error::<T>::NotAuthorized);
--+        
--+            // Ensure the event exists
--+            ensure!(EventStorage::<T>::contains_key(event_id), Error::<T>::EventNotFound);
--+        
--+            // Remove the event from storage
--+            <EventStorage<T>>::remove(event_id);
--+        
--             Self::deposit_event(Event::EventRemoved { event_id });
--             Ok(())
--         }
--@@ -1002,6 +1029,7 @@ pub mod pallet {
--         NoEventsInQueue,
--         JsonSerializationError,
--         DuplicateEvent,
--+        NotAuthorized,
--     }
-- 
--     #[pallet::event]
--@@ -1011,6 +1039,7 @@ pub mod pallet {
--         EventRemoved { event_id: u64 },
--         SomethingDone { param: u32 },
--         EventStored { event_id: u64 },
--+        EventUpdated { who: T::AccountId, event_id: u64 },
--     }
-- 
--     #[pallet::type_value]
--diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
--index 3205930..639efa7 100644
----- a/pallets/pallet-registration/src/mock.rs
--+++ b/pallets/pallet-registration/src/mock.rs
--@@ -164,6 +164,7 @@ parameter_types! {
--     pub static BeforeSessionEndCalled: bool = false;
--     pub static ValidatorAccounts: BTreeMap<u64, u64> = BTreeMap::new();
--     pub const BlockHashCount: u32 = 250;
--+    pub const AdminAccount: MyAccountId = MyAccountId(1);
-- }
-- 
-- impl pallet_session::Config for Test {
--@@ -237,6 +238,7 @@ impl pallet_registration::Config for Test {
--     type AccountId32Convert = MockAccountId32Convert;
--     type Call = RuntimeCall;
--     type UnsignedPriority = frame_support::traits::ConstU64<100>;
--+    type AdminAccount = AdminAccount;
-- }
-- 
-- impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Test
--@@ -361,8 +363,14 @@ pub fn new_test_ext() -> sp_io::TestExternalities {
-- mod tests {
--     use super::*;
--     // use crate::mock::{new_test_ext, Test};
--+    use crate::mock::system::Origin;
--     use crate::mock::{new_test_ext, Registration, Test};
--+    use crate::EventStorage;
--+    use crate::Pallet;
--+    use crate::ProcessedEvents;
--+    use crate::ProcessedTransactions;
--     use frame_support::{assert_noop, assert_ok};
--+    use frame_system::RawOrigin;
--     use sp_runtime::testing::TestSignature;
-- 
--     fn create_test_event() -> CustomEvent {
--@@ -595,19 +603,6 @@ mod tests {
--         });
--     }
-- 
---    //     // This test just ensures the function doesn't panic
---    //     Pallet::<Test>::log_event_processing(&event);
---    // }
---
---    // #[test]
---    // fn test_is_leader() {
---    //     new_test_ext().execute_with(|| {
---    //         // This test might require more setup to properly test leadership
---    //         // For now, we'll just ensure the function runs without panicking
---    //         let _ = Pallet::<Test>::is_leader();
---    //     });
---    // }
---
--     #[test]
--     fn test_pending_events() {
--         new_test_ext().execute_with(|| {
--@@ -622,160 +617,436 @@ mod tests {
--         });
--     }
-- 
---    // #[test]
---    // fn test_process_real_event() {
---    //     new_test_ext().execute_with(|| {
---    //         // This test might be challenging to implement without mocking HTTP requests
---    //         // For now, we'll just check if the function doesn't panic
---    //         let _ = Pallet::<Test>::process_real_event();
---    //     });
---    // }
---
---    // #[test]
---    // fn test_process_response() {
---    //     let data = r#"[{"asset_id":"BTC","quantity":100}]"#.as_bytes().to_vec();
---    //     assert_ok!(Pallet::<Test>::process_response(data));
---    // }
---
---    // #[test]
---    // fn test_processed_events() {
---    //     new_test_ext().execute_with(|| {
---    //         ProcessedEvents::<Test>::insert(1, true);
---    //         assert!(ProcessedEvents::<Test>::contains_key(1));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_processed_events() {
---    //     new_test_ext().execute_with(|| {
---    //         <pallet_registration::Pallet<Test>>::ProcessedEvents::insert(1, true);
---    //         assert!(<pallet_registration::Pallet<Test>>::ProcessedEvents::contains_key(1));
---    //     });
---    // }
---    
---
---
---    // #[test]
---    // fn test_remove_event_from_storage() {
---    //     new_test_ext().execute_with(|| {
---    //         let event = CustomEvent {
---    //             id: 1,
---    //             data: CustomData {
---    //                 event_type: "Test".into(),
---    //                 data: RegistrationData {
---    //                     user_id: "user1".into(),
---    //                     username: "testuser".into(),
---    //                     email: "test@example.com".into(),
---    //                 },
---    //             },
---    //             timestamp: 1000,
---    //             block_height: 10,
---    //         };
---
---    //         EventStorage::<Test>::insert(event.id, event);
---
---    //         assert_ok!(Pallet::<Test>::remove_event_from_storage(Origin::signed(MyAccountId(1)), 1));
---    //         assert!(!EventStorage::<Test>::contains_key(1));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_processed_transactions() {
---    //     new_test_ext().execute_with(|| {
---    //         let payload = vec![0, 1, 2, 3];
---    //         ProcessedTransactions::<Test>::insert(payload.clone(), true);
---    //         assert!(ProcessedTransactions::<Test>::contains_key(payload));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_store_event_in_mempool() {
---    //     new_test_ext().execute_with(|| {
---    //         let event = CustomEvent {
---    //             id: 1,
---    //             data: CustomData {
---    //                 event_type: "Test".into(),
---    //                 data: RegistrationData {
---    //                     user_id: "user1".into(),
---    //                     username: "testuser".into(),
---    //                     email: "test@example.com".into(),
---    //                 },
---    //             },
---    //             timestamp: 1000,
---    //             block_height: 10,
---    //         };
---
---    //         assert_ok!(Pallet::<Test>::store_event_in_mempool(event.clone()));
---    //         assert_eq!(EventStorage::<Test>::get(event.id), event);
---    //     });
---    // }
---
---    // #[test]
---    // fn test_submit_encoded_payload() {
---    //     new_test_ext().execute_with(|| {
---    //         let event = CustomEvent {
---    //             id: 1,
---    //             data: CustomData {
---    //                 event_type: "Test".into(),
---    //                 data: RegistrationData {
---    //                     user_id: "user1".into(),
---    //                     username: "testuser".into(),
---    //                     email: "test@example.com".into(),
---    //                 },
---    //             },
---    //             timestamp: 1000,
---    //             block_height: 10,
---    //         };
---    //         let payload = event.encode();
---    //         assert_ok!(Pallet::<Test>::submit_encoded_payload(Origin::none(), payload));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_submit_unsigned_transaction() {
---    //     new_test_ext().execute_with(|| {
---    //         let event = CustomEvent {
---    //             id: 1,
---    //             data: CustomData {
---    //                 event_type: "Test".into(),
---    //                 data: RegistrationData {
---    //                     user_id: "user1".into(),
---    //                     username: "testuser".into(),
---    //                     email: "test@example.com".into(),
---    //                 },
---    //             },
---    //             timestamp: 1000,
---    //             block_height: 10,
---    //         };
---    //         let payload = event.encode();
---    //         assert_ok!(Pallet::<Test>::submit_unsigned_transaction(payload, 1));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_validate_and_process_event() {
---    //     new_test_ext().execute_with(|| {
---    //         let event = CustomEvent {
---    //             id: 1,
---    //             data: CustomData {
---    //                 event_type: "Test".into(),
---    //                 data: RegistrationData {
---    //                     user_id: "user1".into(),
---    //                     username: "testuser".into(),
---    //                     email: "test@example.com".into(),
---    //                 },
---    //             },
---    //             timestamp: 1000,
---    //             block_height: 10,
---    //         };
---    //         assert_ok!(Pallet::<Test>::validate_and_process_event(event));
---    //     });
---    // }
---
---    // #[test]
---    // fn test_store_event_id() {
---    //     new_test_ext().execute_with(|| {
---    //         assert_ok!(Pallet::<Test>::store_event_id(Origin::none(), "event1".into()));
---    //     });
---    // }
--+    #[test]
--+    fn test_process_response() {
--+        let data = r#"[{"asset_id":"BTC","quantity":100}]"#.as_bytes().to_vec();
--+        assert_ok!(Pallet::<Test>::process_response(data));
--+    }
--+
--+    #[test]
--+    fn test_processed_events() {
--+        new_test_ext().execute_with(|| {
--+            ProcessedEvents::<Test>::insert(1, true);
--+            assert!(ProcessedEvents::<Test>::contains_key(1));
--+        });
--+    }
--+
--+    #[test]
--+    fn test_remove_event_from_storage() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: 1,
--+                data: CustomData {
--+                    event_type: "Test".into(),
--+                    data: RegistrationData {
--+                        user_id: "user1".into(),
--+                        username: "testuser".into(),
--+                        email: "test@example.com".into(),
--+                    },
--+                },
--+                timestamp: 1000,
--+                block_height: 10,
--+            };
--+
--+            EventStorage::<Test>::insert(event.id, event);
--+
--+            assert_ok!(Pallet::<Test>::remove_event_from_storage(
--+                RawOrigin::Signed(MyAccountId(1)).into(),
--+                1
--+            ));
--+            assert!(!EventStorage::<Test>::contains_key(1));
--+        });
--+    }
--+
--+    #[test]
--+    fn test_processed_transactions() {
--+        new_test_ext().execute_with(|| {
--+            let payload = vec![0, 1, 2, 3];
--+            ProcessedTransactions::<Test>::insert(payload.clone(), true);
--+            assert!(ProcessedTransactions::<Test>::contains_key(payload));
--+        });
--+    }
--+
--+    #[test]
--+    fn test_store_event_in_mempool() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: 1,
--+                data: CustomData {
--+                    event_type: "Test".into(),
--+                    data: RegistrationData {
--+                        user_id: "user1".into(),
--+                        username: "testuser".into(),
--+                        email: "test@example.com".into(),
--+                    },
--+                },
--+                timestamp: 1000,
--+                block_height: 10,
--+            };
--+
--+            assert_ok!(Pallet::<Test>::store_event_in_mempool(event.clone()));
--+            assert_eq!(EventStorage::<Test>::get(event.id), event);
--+        });
--+    }
--+
--+    #[test]
--+    fn test_submit_encoded_payload() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: 1,
--+                data: CustomData {
--+                    event_type: "Test".into(),
--+                    data: RegistrationData {
--+                        user_id: "user1".into(),
--+                        username: "testuser".into(),
--+                        email: "test@example.com".into(),
--+                    },
--+                },
--+                timestamp: 1000,
--+                block_height: 10,
--+            };
--+            let payload = event.encode();
--+            assert_ok!(Pallet::<Test>::submit_encoded_payload(
--+                RawOrigin::None.into(),
--+                payload
--+            ));
--+        });
--+    }
--+
--+    #[test]
--+    fn test_validate_and_process_event() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: 1,
--+                data: CustomData {
--+                    event_type: "Test".into(),
--+                    data: RegistrationData {
--+                        user_id: "user1".into(),
--+                        username: "testuser".into(),
--+                        email: "test@example.com".into(),
--+                    },
--+                },
--+                timestamp: 1000,
--+                block_height: 10,
--+            };
--+            assert_ok!(Pallet::<Test>::validate_and_process_event(event));
--+        });
--+    }
--+
--+    #[test]
--+    fn test_store_event_id() {
--+        new_test_ext().execute_with(|| {
--+            assert_ok!(Pallet::<Test>::store_event_id(
--+                RawOrigin::None.into(),
--+                "event1".into()
--+            ));
--+        });
--+    }
--+    #[test]
--+    fn test_submit_event_with_max_values() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: u64::MAX,
--+                data: CustomData {
--+                    event_type: "MaxValueEvent".into(),
--+                    data: RegistrationData {
--+                        user_id: "user123".into(),
--+                        username: "maxuser".into(),
--+                        email: "max@example.com".into(),
--+                    },
--+                },
--+                timestamp: u64::MAX,
--+                block_height: u64::MAX,
--+            };
--+            let payload = event.encode();
--+            assert_ok!(Pallet::<Test>::submit_encoded_payload(
--+                RawOrigin::None.into(),
--+                payload
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+        });
--+    }
--+    #[test]
--+    fn test_submit_event_with_zero_values() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: 0,
--+                data: CustomData {
--+                    event_type: "".into(),
--+                    data: RegistrationData {
--+                        user_id: "".into(),
--+                        username: "".into(),
--+                        email: "".into(),
--+                    },
--+                },
--+                timestamp: 0,
--+                block_height: 0,
--+            };
--+            let payload = event.encode();
--+            assert_ok!(Pallet::<Test>::submit_encoded_payload(
--+                RawOrigin::None.into(),
--+                payload
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+        });
--+    }
--+    #[test]
--+fn test_remove_nonexistent_event_from_storage() {
--+    new_test_ext().execute_with(|| {
--+        let admin_account = MyAccountId(1);
--+        // Attempt to remove a nonexistent event
--+        assert_noop!(
--+            Registration::remove_event_from_storage(RawOrigin::Signed(admin_account).into(), 999),
--+            Error::<Test>::EventNotFound
--+        );
--+    });
--+}
--+    //  #[test]
--+    fn test_event_retrieval() {
--+        new_test_ext().execute_with(|| {
--+            let event = create_test_event();
--+            let payload = event.encode();
--+
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RuntimeOrigin::none(),
--+                payload.clone()
--+            ));
--+
--+            // Retrieve the event by ID
--+            let retrieved_event = Registration::event_storage(event.id);
--+            assert_eq!(retrieved_event, event);
--+        });
--+    }
--+
--+    #[test]
--+    fn test_duplicate_event_detection() {
--+        new_test_ext().execute_with(|| {
--+            let event = create_test_event();
--+            let payload = event.encode();
--+
--+            // First submission should succeed
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RuntimeOrigin::none(),
--+                payload.clone()
--+            ));
--+
--+            // Second submission of the same event should fail due to duplication
--+            assert_noop!(
--+                Registration::submit_encoded_payload(RuntimeOrigin::none(), payload.clone()),
--+                Error::<Test>::DuplicateEvent
--+            );
--+        });
--+    }
--+    #[test]
--+    fn test_large_payload_submission() {
--+        new_test_ext().execute_with(|| {
--+            let large_data = "a".repeat(10_000); // Adjust the size as needed for testing limits
--+            let event = CustomEvent {
--+                id: 1,
--+                data: CustomData {
--+                    event_type: "LargePayloadEvent".into(),
--+                    data: RegistrationData {
--+                        user_id: large_data.clone(),
--+                        username: large_data.clone(),
--+                        email: large_data.clone(),
--+                    },
--+                },
--+                timestamp: 1000,
--+                block_height: 100,
--+            };
--+
--+            let payload = event.encode();
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RawOrigin::None.into(),
--+                payload
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+        });
--+    }
--+    #[test]
--+    fn test_event_update() {
--+        new_test_ext().execute_with(|| {
--+            let event = create_test_event();
--+            let payload = event.encode();
--+
--+            // Submit the event
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RuntimeOrigin::none(),
--+                payload.clone()
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+
--+            // Update the event
--+            let updated_event = CustomEvent {
--+                id: event.id,
--+                data: CustomData {
--+                    event_type: "UpdatedEvent".into(),
--+                    data: RegistrationData {
--+                        user_id: "updated_user".into(),
--+                        username: "updated_user".into(),
--+                        email: "updated@example.com".into(),
--+                    },
--+                },
--+                timestamp: 2000,
--+                block_height: 200,
--+            };
--+
--+            // Use the new update_event method
--+            assert_ok!(Registration::update_event(
--+                RuntimeOrigin::signed(MyAccountId(1)),
--+                event.id,
--+                updated_event.clone()
--+            ));
--+            assert_eq!(Registration::event_storage(updated_event.id), updated_event);
--+        });
--+    }
--+
--+    #[test]
--+    fn test_authorized_event_removal() {
--+        new_test_ext().execute_with(|| {
--+            let event = create_test_event();
--+            let payload = event.encode();
--+
--+            // Submit the event
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RuntimeOrigin::none(),
--+                payload.clone()
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+
--+            // Authorized user removes the event
--+            let authorized_account = MyAccountId(1);
--+            assert_ok!(Registration::remove_event_from_storage(
--+                RawOrigin::Signed(authorized_account).into(),
--+                event.id
--+            ));
--+            assert_eq!(
--+                Registration::event_storage(event.id),
--+                CustomEvent::default()
--+            );
--+        });
--+    }
--+    #[test]
--+    fn test_system_stability_under_load() {
--+        new_test_ext().execute_with(|| {
--+            for i in 0..1_000 {
--+                let event = CustomEvent {
--+                    id: i,
--+                    data: CustomData {
--+                        event_type: "LoadTestEvent".into(),
--+                        data: RegistrationData {
--+                            user_id: format!("user{}", i),
--+                            username: format!("testuser{}", i),
--+                            email: format!("test{}@example.com", i),
--+                        },
--+                    },
--+                    timestamp: 1000,
--+                    block_height: 100,
--+                };
--+
--+                let payload = event.encode();
--+                assert_ok!(Registration::submit_encoded_payload(
--+                    RawOrigin::None.into(),
--+                    payload
--+                ));
--+                assert_eq!(Registration::event_storage(event.id), event);
--+            }
--+        });
--+    }
--+    #[test]
--+    fn test_submit_event_with_min_values() {
--+        new_test_ext().execute_with(|| {
--+            let event = CustomEvent {
--+                id: u64::MIN,
--+                data: CustomData {
--+                    event_type: "".into(),
--+                    data: RegistrationData {
--+                        user_id: "".into(),
--+                        username: "".into(),
--+                        email: "".into(),
--+                    },
--+                },
--+                timestamp: u64::MIN,
--+                block_height: u64::MIN,
--+            };
--+            let payload = event.encode();
--+            assert_ok!(Pallet::<Test>::submit_encoded_payload(
--+                RawOrigin::None.into(),
--+                payload
--+            ));
--+            assert_eq!(Registration::event_storage(event.id), event);
--+        });
--+    }
--+    #[test]
--+    fn test_only_admin_can_remove_event() {
--+        new_test_ext().execute_with(|| {
--+            // Ensure account 1 is treated as an admin
--+            let admin_account = MyAccountId(1);
--+            let non_admin_account = MyAccountId(2);
--+
--+            // Create and submit an event
--+            let event = create_test_event();
--+            let payload = event.encode();
--+            assert_ok!(Registration::submit_encoded_payload(
--+                RuntimeOrigin::none(),
--+                payload.clone()
--+            ));
--+
--+            // Ensure non-admin cannot remove the event
--+            assert_noop!(
--+                Registration::remove_event_from_storage(
--+                    RawOrigin::Signed(non_admin_account).into(),
--+                    event.id
--+                ),
--+                Error::<Test>::NotAuthorized
--+            );
--+
--+            // Ensure admin can remove the event
--+            assert_ok!(Registration::remove_event_from_storage(
--+                RawOrigin::Signed(admin_account).into(),
--+                event.id
--+            ));
--+
--+            // Verify the event has been removed by checking if the storage is empty or default value
--+            assert_eq!(
--+                Registration::event_storage(event.id),
--+                CustomEvent::default()
--+            );
--+        });
--+    }
--+    #[test]
--+    fn test_stress_submit_events() {
--+        new_test_ext().execute_with(|| {
--+            for i in 0..1000 {
--+                let event = CustomEvent {
--+                    id: i,
--+                    data: CustomData {
--+                        event_type: format!("Event{}", i),
--+                        data: RegistrationData {
--+                            user_id: format!("user{}", i),
--+                            username: format!("user{}", i),
--+                            email: format!("user{}@example.com", i),
--+                        },
--+                    },
--+                    timestamp: 1000 + i,
--+                    block_height: 100 + i,
--+                };
--+                let payload = event.encode();
--+                assert_ok!(Pallet::<Test>::submit_encoded_payload(
--+                    RawOrigin::None.into(),
--+                    payload
--+                ));
--+            }
--+        });
--+    }
--+    #[test]
--+    fn test_invalid_event_removal() {
--+        new_test_ext().execute_with(|| {
--+            let account = MyAccountId(1);
--+            assert_noop!(
--+                Registration::remove_event_from_storage(RawOrigin::Signed(account).into(), 999), // Non-existent event ID
--+                Error::<Test>::EventNotFound
--+            );
--+        });
--+    }
-- }
--diff --git a/tests/test.py b/tests/test.py
--index de1e488..bf0dced 100644
----- a/tests/test.py
--+++ b/tests/test.py
--@@ -12,8 +12,13 @@ def send_jsonrpc_request(url, method, params):
--         "method": method,
--         "params": params
--     }
---    response = requests.post(url, json=payload)
---    return response.json()
--+    try:
--+        response = requests.post(url, json=payload)
--+        response.raise_for_status()
--+        return response.json()
--+    except requests.exceptions.RequestException as e:
--+        print(f"Error sending JSON-RPC request: {e}")
--+        return None
-- 
-- def submit_event():
--     event = {
--@@ -32,17 +37,20 @@ def submit_event():
--     priority = 10
--     response = send_jsonrpc_request(QUEUE_URL, "submit_event", [event, priority])
--     print("Event submission response:", response)
---    return event['id']
--+    return event['id'] if response else None
-- 
-- def check_all_storage():
---    # This assumes your pallet's name is 'Registration'
--     prefix = "0x" + "Registration".encode().hex()
--     response = send_jsonrpc_request(NODE_URL, "state_getPairs", [prefix])
--     print("All storage:", json.dumps(response, indent=2))
---    return response.get('result')
--+    return response.get('result') if response else None
-- 
-- def main():
--     event_id = submit_event()
--+    if not event_id:
--+        print("Failed to submit event.")
--+        return
--+
--     print(f"Submitted event with ID: {event_id}")
-- 
--     max_attempts = 30
--@@ -63,4 +71,5 @@ def main():
--         print("Event processing timed out")
-- 
-- if __name__ == "__main__":
---    main()
--\ No newline at end of file
--+    main()
--+
-diff --git a/node/src/chain_spec.rs b/node/src/chain_spec.rs
-index 2b01229..deb2db4 100644
---- a/node/src/chain_spec.rs
-+++ b/node/src/chain_spec.rs
-@@ -1,4 +1,9 @@
--use std::{collections::BTreeMap, str::FromStr};
-+use std::{
-+    collections::{BTreeMap, HashSet},
-+    fs::File,
-+    io::Read,
-+    str::FromStr,
-+};
- 
- use hex_literal::hex;
- use pallet_im_online::sr25519::AuthorityId as ImOnlineId;
-@@ -16,6 +21,7 @@ use aya_runtime::{
-     opaque::SessionKeys, AccountId, Balance, RuntimeGenesisConfig, SS58Prefix, Signature,
-     WASM_BINARY,
- };
-+use serde_json::Value;
- 
- // The URL for the telemetry server.
- // const STAGING_TELEMETRY_URL: &str = "wss://telemetry.polkadot.io/submit/";
-@@ -143,6 +149,27 @@ pub fn local_testnet_config() -> ChainSpec {
-         .build()
- }
- 
-+/// Read Cardano NFT addresses from a JSON file
-+fn get_cardano_nft_addresses() -> HashSet<String> {
-+    let mut file = File::open("src/node_operator_cardano_nfts.json")
-+        .expect("node_operator_cardano_nfts.json file should be present in the src directory");
-+    let mut data = String::new();
-+    file.read_to_string(&mut data)
-+        .expect("Unable to read node_operator_cardano_nfts.json file");
-+    let json: Value = serde_json::from_str(&data).expect("Invalid JSON format");
-+    let addresses = json["addresses"]
-+        .as_array()
-+        .expect("Addresses should be an array");
-+    addresses
-+        .iter()
-+        .map(|addr| {
-+            addr.as_str()
-+                .expect("Address should be a string")
-+                .to_string()
-+        })
-+        .collect()
-+}
-+
- /// Configure initial storage state for FRAME modules.
- fn testnet_genesis(
-     sudo_key: AccountId,
-@@ -195,6 +222,8 @@ fn testnet_genesis(
-         map
-     };
- 
-+    let cardano_nft_addresses: HashSet<String> = get_cardano_nft_addresses();
-+
-     serde_json::json!({
-         "sudo": { "key": Some(sudo_key) },
-         "balances": {
-@@ -213,6 +242,7 @@ fn testnet_genesis(
-         "imOnline": { "keys": [] },
-         "evmChainId": { "chainId": chain_id },
-         "evm": { "accounts": evm_accounts },
--        "manualSeal": { "enable": enable_manual_seal }
-+        "manualSeal": { "enable": enable_manual_seal },
-+        "cardanoNftAddresses": { "addresses": cardano_nft_addresses },
-     })
- }
-diff --git a/pallets/pallet-registration/src/lib.rs b/pallets/pallet-registration/src/lib.rs
-index d95048c..05367f6 100644
---- a/pallets/pallet-registration/src/lib.rs
-+++ b/pallets/pallet-registration/src/lib.rs
-@@ -984,16 +984,19 @@ pub mod pallet {
-             event_id: u64,
-         ) -> DispatchResult {
-             let who = ensure_signed(origin)?;
--        
-+
-             // Ensure the caller is an admin
-             ensure!(who == T::AdminAccount::get(), Error::<T>::NotAuthorized);
--        
-+
-             // Ensure the event exists
--            ensure!(EventStorage::<T>::contains_key(event_id), Error::<T>::EventNotFound);
--        
-+            ensure!(
-+                EventStorage::<T>::contains_key(event_id),
-+                Error::<T>::EventNotFound
-+            );
-+
-             // Remove the event from storage
-             <EventStorage<T>>::remove(event_id);
--        
-+
-             Self::deposit_event(Event::EventRemoved { event_id });
-             Ok(())
-         }
-diff --git a/pallets/pallet-registration/src/mock.rs b/pallets/pallet-registration/src/mock.rs
-index 639efa7..ac8f587 100644
---- a/pallets/pallet-registration/src/mock.rs
-+++ b/pallets/pallet-registration/src/mock.rs
-@@ -791,16 +791,19 @@ mod tests {
-         });
-     }
-     #[test]
--fn test_remove_nonexistent_event_from_storage() {
--    new_test_ext().execute_with(|| {
--        let admin_account = MyAccountId(1);
--        // Attempt to remove a nonexistent event
--        assert_noop!(
--            Registration::remove_event_from_storage(RawOrigin::Signed(admin_account).into(), 999),
--            Error::<Test>::EventNotFound
--        );
--    });
--}
-+    fn test_remove_nonexistent_event_from_storage() {
-+        new_test_ext().execute_with(|| {
-+            let admin_account = MyAccountId(1);
-+            // Attempt to remove a nonexistent event
-+            assert_noop!(
-+                Registration::remove_event_from_storage(
-+                    RawOrigin::Signed(admin_account).into(),
-+                    999
-+                ),
-+                Error::<Test>::EventNotFound
-+            );
-+        });
-+    }
-     //  #[test]
-     fn test_event_retrieval() {
-         new_test_ext().execute_with(|| {
-diff --git a/pallets/substrate-validator-set/Cargo.toml b/pallets/substrate-validator-set/Cargo.toml
-index 28968bd..16e04cb 100644
---- a/pallets/substrate-validator-set/Cargo.toml
-+++ b/pallets/substrate-validator-set/Cargo.toml
-@@ -7,32 +7,29 @@ license = 'Apache-2.0'
- repository = 'https://github.com/gautamdhameja/substrate-validator-set'
- 
- [dependencies]
--sp-core = { workspace = true }
--sp-io = { workspace = true }
--sp-runtime = { workspace = true }
--sp-std = { workspace = true }
--sp-staking = { workspace = true }
--frame-benchmarking = { workspace = true }
--frame-support = { workspace = true }
--frame-system = { workspace = true }
--pallet-session = { workspace = true }
--sp-weights = { workspace = true }
--scale-info = { workspace = true }
--log = { workspace = true }
--scale-codec = { workspace = true }
-+sp-core = { workspace = true, default-features = false }
-+sp-io = { workspace = true, default-features = false }
-+sp-runtime = { workspace = true, default-features = false }
-+sp-std = { workspace = true, default-features = false }
-+sp-staking = { workspace = true, default-features = false }
-+frame-benchmarking = { workspace = true, default-features = false, optional = true }
-+frame-support = { workspace = true, default-features = false }
-+frame-system = { workspace = true, default-features = false }
-+pallet-session = { workspace = true, default-features = false }
-+sp-weights = { workspace = true, default-features = false }
-+scale-info = { workspace = true, default-features = false, features = ["derive"] }
-+log = { workspace = true, default-features = false }
-+scale-codec = { workspace = true, default-features = false, features = ["derive"] }
- 
- 
- [dev-dependencies]
--sp-state-machine = { workspace = true }
-+sp-state-machine = { workspace = true, default-features = false }
- serde = { workspace = true }
--
--
- [features]
- default = ['std']
--runtime-benchmarks = ['frame-benchmarking/runtime-benchmarks']
- std = [
-     'scale-codec/std',
--    'frame-benchmarking/std',
-+    'frame-benchmarking?/std',
-     'frame-support/std',
-     'frame-system/std',
-     'scale-info/std',
-@@ -40,6 +37,10 @@ std = [
-     'sp-io/std',
-     'sp-std/std',
-     'sp-runtime/std',
-+    'sp-staking/std',
-     'pallet-session/std',
-+    'log/std',
-+    # 'cardano-serialization-lib/std',
- ]
--try-runtime = ['frame-support/try-runtime']
-+runtime-benchmarks = ['frame-benchmarking/runtime-benchmarks']
-+try-runtime = ['frame-support/try-runtime']
-\ No newline at end of file
-diff --git a/pallets/substrate-validator-set/src/lib.rs b/pallets/substrate-validator-set/src/lib.rs
-index 95e5899..2088e6f 100644
---- a/pallets/substrate-validator-set/src/lib.rs
-+++ b/pallets/substrate-validator-set/src/lib.rs
-@@ -1,30 +1,22 @@
--//! # Validator Set Pallet
--//!
--//! The Validator Set Pallet allows addition and removal of
--//! authorities/validators via extrinsics (transaction calls), in
--//! Substrate-based PoA networks. It also integrates with the im-online pallet
--//! to automatically remove offline validators.
--//!
--//! The pallet depends on the Session pallet and implements related traits for session
--//! management. Currently it uses periodic session rotation provided by the
--//! session pallet to automatically rotate sessions. For this reason, the
--//! validator addition and removal becomes effective only after 2 sessions
--//! (queuing + applying).
--
- #![cfg_attr(not(feature = "std"), no_std)]
- 
- mod benchmarking;
- mod mock;
- mod tests;
- pub mod weights;
--
--use core::fmt::Debug;
-+// extern crate cardano_serialization_lib;
-+// use cardano_serialization_lib::crypto::PrivateKey;
-+// use cardano_serialization_lib::address::BaseAddress;
-+use core::{fmt::Debug, str};
- use frame_support::{
- 	ensure,
- 	pallet_prelude::*,
- 	traits::{EstimateNextSessionRotation, Get, ValidatorSet, ValidatorSetWithIdentification},
- 	DefaultNoBound,
- };
-+use sp_core::{blake2_256, crypto::UncheckedFrom, ed25519, Pair};
-+use sp_std::convert::TryFrom;
-+
- use frame_system::pallet_prelude::*;
- use log;
- pub use pallet::*;
-@@ -36,6 +28,36 @@ pub use weights::*;
- 
- pub const LOG_TARGET: &'static str = "runtime::validator-set";
- 
-+pub struct CardanoAddress {
-+	payment_part: [u8; 28],
-+	network_tag: u8,
-+}
-+impl Clone for CardanoAddress {
-+    fn clone(&self) -> Self {
-+        CardanoAddress {
-+            payment_part: self.payment_part,
-+            network_tag: self.network_tag,
-+        }
-+    }
-+}
-+impl CardanoAddress {
-+	pub fn new(address: &[u8]) -> Option<Self> {
-+		if address.len() != 29 {
-+			return None;
-+		}
-+		let mut payment_part = [0u8; 28];
-+		payment_part.copy_from_slice(&address[0..28]);
-+		Some(CardanoAddress { payment_part, network_tag: address[28] })
-+	}
-+
-+	pub fn to_bytes(&self) -> Vec<u8> {
-+		let mut result = Vec::with_capacity(29);
-+		result.extend_from_slice(&self.payment_part);
-+		result.push(self.network_tag);
-+		result
-+	}
-+}
-+
- #[frame_support::pallet()]
- pub mod pallet {
- 	use super::*;
-@@ -71,6 +93,15 @@ pub mod pallet {
- 	#[pallet::getter(fn offline_validators)]
- 	pub type OfflineValidators<T: Config> = StorageValue<_, Vec<T::ValidatorId>, ValueQuery>;
- 
-+	#[pallet::storage]
-+	#[pallet::getter(fn cardano_nft_addresses)]
-+	pub type CardanoNftAddresses<T: Config> =
-+		StorageMap<_, Blake2_128Concat, Vec<u8>, (Vec<u8>, Vec<u8>)>;
-+
-+	#[pallet::storage]
-+	#[pallet::getter(fn validator_public_keys)]
-+	pub type ValidatorPublicKeys<T: Config> = StorageValue<_, Vec<Vec<u8>>, ValueQuery>;
-+
- 	#[pallet::event]
- 	#[pallet::generate_deposit(pub(super) fn deposit_event)]
- 	pub enum Event<T: Config> {
-@@ -91,6 +122,8 @@ pub mod pallet {
- 		Duplicate,
- 		InvalidNFTMintEvent,
- 		NotEligible,
-+		InvalidCardanoKey,
-+		InvalidCardanoAddress,
- 	}
- 
- 	#[pallet::hooks]
-@@ -145,58 +178,155 @@ pub mod pallet {
- 
- 			Ok(())
- 		}
-+
- 		#[pallet::call_index(2)]
- 		#[pallet::weight(<T as pallet::Config>::WeightInfo::register_validator())]
- 		pub fn register_validator(
- 			origin: OriginFor<T>,
- 			nft_policy_id: Vec<u8>,
- 			nft_asset_name: Vec<u8>,
-+			cardano_address: Vec<u8>,
- 			recipient_address: T::AccountId,
--			tx_hash: Vec<u8>,
--			tx_slot: u64,
-+			cardano_private_key: Vec<u8>,
- 		) -> DispatchResult {
- 			let who = ensure_signed(origin)?;
--
-+	
- 			ensure!(
--				Self::verify_nft_mint_event(
-+				Self::verify_cardano_nft_owner(
-+					&cardano_address,
- 					&nft_policy_id,
- 					&nft_asset_name,
--					&recipient_address,
--					&tx_hash,
--					tx_slot
--				),
--				Error::<T>::InvalidNFTMintEvent
-+					&cardano_private_key
-+				)?,
-+				Error::<T>::NotEligible
- 			);
--
--			ensure!(Self::is_eligible_validator(&recipient_address), Error::<T>::NotEligible);
--
-+	
- 			let validator_id = T::ValidatorIdOf::convert(recipient_address.clone())
- 				.ok_or(Error::<T>::NotEligible)?;
--
-+	
- 			Self::do_add_validator(validator_id.clone())?;
--
-+	
- 			Self::deposit_event(Event::ValidatorRegistered(validator_id));
-+	
-+			Ok(())
-+		}
-+		
- 
-+		#[pallet::weight(10_000)]
-+		pub fn add_nft_address(
-+			origin: OriginFor<T>,
-+			cardano_address: Vec<u8>,
-+			policy_id: Vec<u8>,
-+			asset_name: Vec<u8>,
-+		) -> DispatchResult {
-+			ensure_root(origin)?;
-+			CardanoNftAddresses::<T>::insert(cardano_address, (policy_id, asset_name));
-+			Ok(())
-+		}
-+
-+		#[pallet::weight(10_000)]
-+		pub fn remove_nft_address(
-+			origin: OriginFor<T>,
-+			cardano_address: Vec<u8>,
-+		) -> DispatchResult {
-+			ensure_root(origin)?;
-+			CardanoNftAddresses::<T>::remove(cardano_address);
- 			Ok(())
- 		}
- 	}
- }
- 
- impl<T: Config> Pallet<T> {
--	fn verify_nft_mint_event(
-+	fn private_key_to_public(private_key: &[u8]) -> Option<[u8; 32]> {
-+		if private_key.len() != 32 {
-+			return None;
-+		}
-+		let seed = private_key.try_into().ok()?;
-+		let pair = ed25519::Pair::from_seed(&seed);
-+		Some(pair.public().0)
-+	}
-+	pub fn derive_cardano_address(public_key: &[u8], network_tag: u8) -> Option<CardanoAddress> {
-+		if public_key.len() != 32 {
-+			return None;
-+		}
-+		let ed25519_public = ed25519::Public::try_from(public_key).ok()?;
-+		let hashed_key = blake2_256(ed25519_public.as_ref());
-+		let mut payment_part = [0u8; 28];
-+		payment_part.copy_from_slice(&hashed_key[0..28]);
-+		Some(CardanoAddress { payment_part, network_tag })
-+	}
-+
-+	pub fn verify_cardano_address(address: &CardanoAddress, public_key: &[u8]) -> bool {
-+		if let Some(derived_address) = Self::derive_cardano_address(public_key, address.network_tag)
-+		{
-+			derived_address.payment_part == address.payment_part
-+		} else {
-+			false
-+		}
-+	}
-+	fn is_eligible_validator(
-+		cardano_address: &[u8],
- 		nft_policy_id: &[u8],
- 		nft_asset_name: &[u8],
--		recipient_address: &T::AccountId,
--		tx_hash: &[u8],
--		tx_slot: u64,
- 	) -> bool {
--		// Implement your verification logic here
--		true // Placeholder implementation
--	}
-+		fn is_valid_nft(policy_id: &[u8], asset_name: &[u8]) -> bool {
-+			let valid_nfts = vec![("policy_id_1", "asset_name_1"), ("policy_id_2", "asset_name_2")];
-+			let policy_id_str = core::str::from_utf8(policy_id).ok();
-+			let asset_name_str = core::str::from_utf8(asset_name).ok();
-+
-+			match (policy_id_str, asset_name_str) {
-+				(Some(policy_id_str), Some(asset_name_str)) => {
-+					valid_nfts.contains(&(policy_id_str, asset_name_str))
-+				},
-+				_ => false,
-+			}
-+		}
- 
--	fn is_eligible_validator(account: &T::AccountId) -> bool {
--		// Implement your eligibility check logic here
--		true // Placeholder implementation
-+		// Check if the Cardano address owns this NFT
-+		Self::check_nft_ownership(cardano_address, nft_policy_id, nft_asset_name)
-+			&& is_valid_nft(nft_policy_id, nft_asset_name)
-+	}
-+	fn verify_cardano_nft_owner(
-+		cardano_address: &[u8],
-+		nft_policy_id: &[u8],
-+		nft_asset_name: &[u8],
-+		cardano_private_key: &[u8],
-+	) -> Result<bool, DispatchError> {
-+		// First, verify the private key
-+		let public_key = Self::private_key_to_public(cardano_private_key)
-+			.ok_or(Error::<T>::InvalidCardanoKey)?;
-+	
-+		// Derive address from public key
-+		let derived_address = Self::derive_cardano_address(&public_key, cardano_address[28])
-+			.ok_or(Error::<T>::InvalidCardanoAddress)?;
-+	
-+		// Check if derived address matches the provided address
-+		if derived_address.to_bytes() != cardano_address {
-+			return Err(Error::<T>::InvalidCardanoAddress.into());
-+		}
-+	
-+		// Check if the address is in storage
-+		let stored_nft = CardanoNftAddresses::<T>::get(cardano_address.to_vec());
-+	
-+		match stored_nft {
-+			Some((stored_policy_id, stored_asset_name)) => {
-+				// Check if the stored NFT matches the provided NFT
-+				if stored_policy_id == nft_policy_id && stored_asset_name == nft_asset_name {
-+					Ok(true)
-+				} else {
-+					Ok(false)
-+				}
-+			},
-+			None => Ok(false),
-+		}
-+	}
-+	fn check_nft_ownership(address: &[u8], policy_id: &[u8], asset_name: &[u8]) -> bool {
-+		let key = address.to_vec();
-+		if let Some((stored_policy_id, stored_asset_name)) = CardanoNftAddresses::<T>::get(key) {
-+			stored_policy_id == policy_id && stored_asset_name == asset_name
-+		} else {
-+			false
-+		}
- 	}
- 
- 	fn do_add_validator(
-diff --git a/pallets/substrate-validator-set/src/tests.rs b/pallets/substrate-validator-set/src/tests.rs
-index 7c0c7e4..f2b11f3 100644
---- a/pallets/substrate-validator-set/src/tests.rs
-+++ b/pallets/substrate-validator-set/src/tests.rs
-@@ -1,11 +1,159 @@
--//! Tests for the Validator Set pallet.
--
- #![cfg(test)]
- 
- use super::*;
- use crate::mock::{authorities, new_test_ext, RuntimeOrigin, Session, Test, ValidatorSet};
- use frame_support::{assert_noop, assert_ok, pallet_prelude::*};
-+use pallet_session::SessionManager;
- use sp_runtime::testing::UintAuthorityId;
-+use sp_runtime::traits::BadOrigin;
-+use frame_system::Origin;
-+use frame_system::RawOrigin;
-+
-+
-+#[test]
-+fn test_real_cardano_address_verification() {
-+    new_test_ext().execute_with(|| {
-+        let private_key = ed25519::Pair::generate().0.to_raw_vec();
-+        let public_key = ValidatorSet::private_key_to_public(&private_key).unwrap();
-+        let cardano_address = ValidatorSet::derive_cardano_address(&public_key, 1).unwrap();
-+        let cardano_address_bytes = cardano_address.to_bytes();
-+
-+        let nft_policy_id = vec![1, 2, 3, 4];
-+        let nft_asset_name = vec![5, 6, 7, 8];
-+
-+        // Add the NFT to storage
-+        assert_ok!(ValidatorSet::add_nft_address(
-+            RawOrigin::Root.into(),
-+            cardano_address_bytes.clone(),
-+            nft_policy_id.clone(),
-+            nft_asset_name.clone()
-+        ));
-+
-+        assert!(ValidatorSet::verify_cardano_nft_owner(
-+            &cardano_address_bytes,
-+            &nft_policy_id,
-+            &nft_asset_name,
-+            &private_key
-+        ).unwrap());
-+    });
-+}
-+
-+#[test]
-+fn it_rotates_sessions() {
-+	new_test_ext().execute_with(|| {
-+		let validator_id = 4;
-+		assert_ok!(ValidatorSet::add_validator(RawOrigin::Root.into(), validator_id));
-+		assert!(ValidatorSet::validators().contains(&validator_id));
-+
-+		// Simulate session end
-+		ValidatorSet::end_session(0);
-+		ValidatorSet::start_session(1);
-+
-+		// Ensure the new session includes the added validator
-+		assert!(ValidatorSet::validators().contains(&validator_id));
-+	});
-+}
-+
-+#[test]
-+fn test_register_validator() {
-+    new_test_ext().execute_with(|| {
-+        let private_key = ed25519::Pair::generate().0.to_raw_vec();
-+        let public_key = ValidatorSet::private_key_to_public(&private_key).unwrap();
-+        let cardano_address = ValidatorSet::derive_cardano_address(&public_key, 1).unwrap();
-+        let cardano_address_bytes = cardano_address.to_bytes();
-+
-+        let nft_policy_id = vec![1, 2, 3, 4];
-+        let nft_asset_name = vec![5, 6, 7, 8];
-+        let recipient_address = 4u64.into(); // Changed from 1 to 4 to ensure it's not in the initial set
-+
-+        // Add the NFT to storage
-+        assert_ok!(ValidatorSet::add_nft_address(
-+            RawOrigin::Root.into(),
-+            cardano_address_bytes.clone(),
-+            nft_policy_id.clone(),
-+            nft_asset_name.clone()
-+        ));
-+
-+        // Ensure the validator is not already in the set
-+        assert!(!<Validators<Test>>::get().contains(&recipient_address));
-+
-+        // Register the validator
-+        assert_ok!(ValidatorSet::register_validator(
-+            RuntimeOrigin::signed(1),
-+            nft_policy_id,
-+            nft_asset_name,
-+            cardano_address_bytes,
-+            recipient_address,
-+            private_key,
-+        ));
-+
-+        // Check if the validator was added
-+        assert!(<Validators<Test>>::get().contains(&recipient_address));
-+    });
-+}
-+
-+#[test]
-+fn it_fails_to_register_invalid_validator() {
-+    new_test_ext().execute_with(|| {
-+        let private_key = vec![0; 32]; // Invalid key
-+        let public_key = ValidatorSet::private_key_to_public(&private_key).unwrap();
-+        let cardano_address = ValidatorSet::derive_cardano_address(&public_key, 1).unwrap().to_bytes();
-+        let nft_policy_id = vec![1, 2, 3, 4];
-+        let nft_asset_name = vec![5, 6, 7, 8];
-+        let recipient_address = 4u64.into();
-+
-+        // Add the NFT to storage to pass the NFT ownership check
-+        assert_ok!(ValidatorSet::add_nft_address(
-+            RawOrigin::Root.into(),
-+            cardano_address.clone(),
-+            nft_policy_id.clone(),
-+            nft_asset_name.clone()
-+        ));
-+
-+        // Attempt to register the validator with invalid address
-+        let invalid_address = vec![9; 29]; // Invalid address
-+        let result = ValidatorSet::register_validator(
-+            RuntimeOrigin::signed(1),
-+            nft_policy_id.clone(),
-+            nft_asset_name.clone(),
-+            invalid_address.clone(),
-+            recipient_address,
-+            private_key.clone()
-+        );
-+
-+        // Print the error for debugging
-+        println!("Error: {:?}", result);
-+
-+        // Check each step of the verification process
-+        let verify_result = ValidatorSet::verify_cardano_nft_owner(
-+            &invalid_address,
-+            &nft_policy_id,
-+            &nft_asset_name,
-+            &private_key
-+        );
-+        println!("Verify result: {:?}", verify_result);
-+
-+        assert_noop!(
-+            result,
-+            Error::<Test>::InvalidCardanoAddress
-+        );
-+    });
-+}
-+
-+#[test]
-+fn it_removes_validator() {
-+	new_test_ext().execute_with(|| {
-+		let validator_id = 1;
-+		// Ensure initial state is clean
-+		if !ValidatorSet::validators().contains(&validator_id) {
-+			assert_ok!(ValidatorSet::add_validator(RawOrigin::Root.into(), validator_id));
-+		}
-+		assert!(ValidatorSet::validators().contains(&validator_id));
-+
-+		assert_ok!(ValidatorSet::remove_validator(RawOrigin::Root.into(), validator_id));
-+		assert!(!ValidatorSet::validators().contains(&validator_id));
-+	});
-+}
- 
- #[test]
- fn simple_setup_should_work() {
-@@ -19,7 +167,7 @@ fn simple_setup_should_work() {
- #[test]
- fn add_validator_updates_validators_list() {
- 	new_test_ext().execute_with(|| {
--		assert_ok!(ValidatorSet::add_validator(RuntimeOrigin::root(), 4));
-+		assert_ok!(ValidatorSet::add_validator(RawOrigin::Root.into(), 4));
- 		assert_eq!(ValidatorSet::validators(), vec![1u64, 2u64, 3u64, 4u64])
- 	});
- }
-@@ -27,41 +175,41 @@ fn add_validator_updates_validators_list() {
- #[test]
- fn remove_validator_updates_validators_list() {
- 	new_test_ext().execute_with(|| {
--		assert_ok!(ValidatorSet::remove_validator(RuntimeOrigin::root(), 2));
-+		assert_ok!(ValidatorSet::remove_validator(RawOrigin::Root.into(), 2));
- 		assert_eq!(ValidatorSet::validators(), &[1, 3]);
- 		// Add validator again
--		assert_ok!(ValidatorSet::add_validator(RuntimeOrigin::root(), 2));
-+		assert_ok!(ValidatorSet::add_validator(RawOrigin::Root.into(), 2));
- 		assert_eq!(ValidatorSet::validators(), &[1, 3, 2]);
- 	});
- }
- 
- #[test]
- fn add_validator_fails_with_invalid_origin() {
--	new_test_ext().execute_with(|| {
--		assert_noop!(
--			ValidatorSet::add_validator(RuntimeOrigin::signed(1), 4),
--			DispatchError::BadOrigin
--		);
--	});
-+    new_test_ext().execute_with(|| {
-+        assert_noop!(
-+            ValidatorSet::add_validator(RuntimeOrigin::signed(1), 4),
-+            DispatchError::BadOrigin
-+        );
-+    });
- }
- 
- #[test]
- fn remove_validator_fails_with_invalid_origin() {
--	new_test_ext().execute_with(|| {
--		assert_noop!(
--			ValidatorSet::remove_validator(RuntimeOrigin::signed(1), 4),
--			DispatchError::BadOrigin
--		);
--	});
-+    new_test_ext().execute_with(|| {
-+        assert_noop!(
-+            ValidatorSet::remove_validator(RuntimeOrigin::signed(1), 4),
-+            DispatchError::BadOrigin
-+        );
-+    });
- }
- 
- #[test]
- fn duplicate_check() {
- 	new_test_ext().execute_with(|| {
--		assert_ok!(ValidatorSet::add_validator(RuntimeOrigin::root(), 4));
-+		assert_ok!(ValidatorSet::add_validator(RawOrigin::Root.into(), 4));
- 		assert_eq!(ValidatorSet::validators(), vec![1u64, 2u64, 3u64, 4u64]);
- 		assert_noop!(
--			ValidatorSet::add_validator(RuntimeOrigin::root(), 4),
-+			ValidatorSet::add_validator(RawOrigin::Root.into(), 4),
- 			Error::<Test>::Duplicate
- 		);
- 	});
-diff --git a/runtime/Cargo.toml b/runtime/Cargo.toml
-index 75a80d4..565d7ab 100644
---- a/runtime/Cargo.toml
-+++ b/runtime/Cargo.toml
-@@ -84,6 +84,7 @@ default = ["std", "with-rocksdb-weights"]
- with-rocksdb-weights = []
- with-paritydb-weights = []
- std = [
-+	
- 	"sp-application-crypto/std",
- 	"scale-codec/std",
- 	"scale-info/std",
